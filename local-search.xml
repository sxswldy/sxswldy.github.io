<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/07/19/%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BATEST/"/>
    <url>/2024/07/19/%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BATEST/</url>
    
    <content type="html"><![CDATA[<p><img src="/./../images/image-20240719131702852.png" alt="image-20240719131702852"></p><p>大撒大撒大撒</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机克隆</title>
    <link href="/2024/07/15/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%8B%E9%9A%86/"/>
    <url>/2024/07/15/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%8B%E9%9A%86/</url>
    
    <content type="html"><![CDATA[<h1 id="克隆虚拟机后无法上网问题"><a href="#克隆虚拟机后无法上网问题" class="headerlink" title="克隆虚拟机后无法上网问题"></a>克隆虚拟机后无法上网问题</h1><p>解决方法：在克隆的虚拟机关闭状态，重新自动配置网络</p><p><img src="/./assets/image-20240715125801353.png" alt="image-20240715125801353"></p><p>然后点击移除该网络适配器，然后再添加一个新的网络适配器即可，生成网络适配器后，进行新的mac地址生成。</p><p><img src="/./assets/image-20240715125820730.png" alt="image-20240715125820730"></p><p>进入&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth33文件把uuid删除，然后重启即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">service network restart<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/07/13/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    <url>/2024/07/13/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="title：接口性能测试"><a href="#title：接口性能测试" class="headerlink" title="title：接口性能测试"></a>title：接口性能测试</h2><h1 id="迭代点"><a href="#迭代点" class="headerlink" title="迭代点"></a>迭代点</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>短链接生成</title>
    <link href="/2024/07/13/%E7%9F%AD%E9%93%BE%E6%8E%A5/%E7%9F%AD%E9%93%BE%E6%8E%A5%E7%94%9F%E6%88%90/"/>
    <url>/2024/07/13/%E7%9F%AD%E9%93%BE%E6%8E%A5/%E7%9F%AD%E9%93%BE%E6%8E%A5%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<p><img src="/./../images/image-20240715194528411.png" alt="image-20240715194528411"></p><h2 id="使用的什么方式生成短链接？"><a href="#使用的什么方式生成短链接？" class="headerlink" title="使用的什么方式生成短链接？"></a>使用的什么方式生成短链接？</h2><p>主要就是两个方面，通过 Hash 算法将原始连接转换成一个 Hash 码，这里使用了 Google 出品的 MurmurHash 算法。因为生成的 Hash 码是十进制的，整体较长不利于短链接传播。为此，我们将十进制转换为 62 进制，也就是咱们最终的短链接。</p><h3 id="1-MurmurHash-算法"><a href="#1-MurmurHash-算法" class="headerlink" title="1. MurmurHash 算法"></a>1. MurmurHash 算法</h3><p>对于选择哈希函数，有很多人可能会提到使用 MD5、SHA 等加密算法。其实我们并不关心反向解密的难度，更重要的是关注哈希的运算速度和冲突概率。</p><p>最终推荐使用由 Google 开发的 MurmurHash 算法。MurmurHash 是一种非加密型哈希函数，适用于一般的哈希检索操作。与其他流行的哈希函数相比，MurmurHash 在处理规律性较强的键时具有更好的随机分布特性。由于它是非加密型的，相比 MD5、SHA 等加密算法，MurmurHash 的性能要高得多（实际上是 MD5 等加密算法的十倍以上）。正是由于这些优点，尽管它于 2008 年问世，但目前已广泛应用于 Redis、MemCache、Cassandra、HBase、Lucene 等许多知名软件中。</p><p>我们使用 Hutool 里的工具类，不过他的底层也是使用的 Google 算法。</p><h3 id="2-进制转换"><a href="#2-进制转换" class="headerlink" title="2. 进制转换"></a>2. 进制转换</h3><p>Base62 编码是将数据转换为只包含数字和字母的一种方法。它使用了 62 个字符，分别是 0-9、a-z、A-Z，可以作为 URL 短链接、文件名等场景的字符串表示，相对于 16 进制或 64 进制等其他编码，Base62 具有更高的可读性和稳定性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span>[] CHARS = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<br>        <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-string">&#x27;J&#x27;</span>, <span class="hljs-string">&#x27;K&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-string">&#x27;N&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;P&#x27;</span>, <span class="hljs-string">&#x27;Q&#x27;</span>, <span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-string">&#x27;S&#x27;</span>, <span class="hljs-string">&#x27;T&#x27;</span>, <span class="hljs-string">&#x27;U&#x27;</span>, <span class="hljs-string">&#x27;V&#x27;</span>, <span class="hljs-string">&#x27;W&#x27;</span>, <span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-string">&#x27;Y&#x27;</span>, <span class="hljs-string">&#x27;Z&#x27;</span>,<br>        <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;j&#x27;</span>, <span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;q&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span><br>&#125;;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIZE</span> <span class="hljs-operator">=</span> CHARS.length;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">convertDecToBase62</span><span class="hljs-params">(<span class="hljs-type">long</span> num)</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">while</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (num % SIZE);<br>        sb.append(CHARS[i]);<br>        num /= SIZE;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.reverse().toString();<br>&#125;<br></code></pre></td></tr></table></figure><p>假设我们使用的是 26 个字母的大小写，加上 10 个数字，那么对于短链接可以表示的最大组合数量为：</p><p>N &#x3D; 4，组合数为 62 ^ 4 &#x3D; 14_776_336，1477 万左右。</p><p>N &#x3D; 5，组合数为 62 ^ 5 &#x3D; 916_132_832，9.16 亿左右。</p><p>N &#x3D; 6，组合数为 62 ^ 6 &#x3D; 56_800_235_584，568 亿左右。</p><img src="C:\Users\34351\AppData\Roaming\Typora\typora-user-images\image-20240713150151051.png" alt="image-20240713150151051" style="zoom: 80%;" /><h2 id="为什么会冲突？"><a href="#为什么会冲突？" class="headerlink" title="为什么会冲突？"></a>为什么会冲突？</h2><p>哈希函数将输入的数据映射为一个固定长度的哈希值，而不同的输入可能会映射为相同的哈希值，这被称为哈希冲突。</p><p>在短链接生成过程中，原始长链接经过哈希函数进行计算，生成一个哈希值。如果两个不同的原始长链接经过哈希计算后得到相同的哈希值，那么它们将生成相同的短链接。</p><p>这种情况通常是由于哈希函数的输出空间有限，而输入空间却是无限的。因此，无论哈希函数的设计有多好，仍然存在一定的概率会出现冲突。</p><h2 id="为什么使用原始链接和-UUID-生成短链接？"><a href="#为什么使用原始链接和-UUID-生成短链接？" class="headerlink" title="为什么使用原始链接和 UUID 生成短链接？"></a>为什么使用原始链接和 UUID 生成短链接？</h2><p>生成的短链接是需要保障在当前域名下唯一的，那这个唯一又如何体现呢？每次查询数据库中已有短链接数据来判断是否唯一么？性能有点低，我们使用了布隆过滤器来进行判断。</p><p>当我们发现冲突后，将原始长链接与一个随机生成的 UUID 字符串拼接，通过拼接后的内容继续查询布隆过滤器，直到不存在为止。</p><h2 id="如果一直冲突怎么办？"><a href="#如果一直冲突怎么办？" class="headerlink" title="如果一直冲突怎么办？"></a>如果一直冲突怎么办？</h2><p>一直冲突的概率是很小的，但是针对这种概率事件，我们就要考虑到极端情况。为此，我们在代码加了一个判断变量，如果超过指定次数，就抛出异常。</p>]]></content>
    
    
    <categories>
      
      <category>短链接</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>抽奖系统部署</title>
    <link href="/2024/07/12/%E5%A4%A7%E8%90%A5%E9%94%80%E9%A1%B9%E7%9B%AE/%E5%A4%A7%E8%90%A5%E9%94%80%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    <url>/2024/07/12/%E5%A4%A7%E8%90%A5%E9%94%80%E9%A1%B9%E7%9B%AE/%E5%A4%A7%E8%90%A5%E9%94%80%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="需要的项目"><a href="#需要的项目" class="headerlink" title="需要的项目"></a><strong>需要的项目</strong></h1><p> <a href="........%5Cjavaproject%5Cbig-market-front">big-market-front</a>（前端） 、 <a href="........%5Cjavaproject%5Cbig-market">big-market</a> （后端）、 <a href="........%5Cjavaproject%5Cbig-market-dev-ops">big-market-dev-ops</a> （部署）</p><h1 id="构建后端镜像"><a href="#构建后端镜像" class="headerlink" title="构建后端镜像"></a>构建后端镜像</h1><p>1.进入后端项目，切换到指定分支</p><p>2.mvn clean install</p><p>3.根据dockfile文件docker build创建后端镜像</p><h1 id="构建前端镜像"><a href="#构建前端镜像" class="headerlink" title="构建前端镜像"></a>构建前端镜像</h1><p>1.进入前端项目，切换到相应分支</p><p>2.修改.env文件相应内容</p><p>3.根据dockfile文件docker build构建镜像</p><h1 id="整体构建"><a href="#整体构建" class="headerlink" title="整体构建"></a>整体构建</h1><p>1.进入部署项目</p><p>2.运行两个docker-compose文件</p>]]></content>
    
    
    <categories>
      
      <category>抽奖系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记录git的一些问题及解决方法</title>
    <link href="/2024/07/11/git%E6%8A%A5%E9%94%99%E6%80%BB%E7%BB%93/"/>
    <url>/2024/07/11/git%E6%8A%A5%E9%94%99%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="克隆不通怎么办"><a href="#克隆不通怎么办" class="headerlink" title="克隆不通怎么办"></a>克隆不通怎么办</h1><p>一般从http换成git克隆就可以了。</p><h1 id="解决Git报错：fatal-detected-dubious-ownership-in-repository-at"><a href="#解决Git报错：fatal-detected-dubious-ownership-in-repository-at" class="headerlink" title="解决Git报错：fatal: detected dubious ownership in repository at"></a>解决Git报错：fatal: detected dubious ownership in repository at</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>这是因为该项目的所有者与现在的Windows用户不一致，从而Git触发了对仓库不安全操作的保护机制</p><p>比如说： 该项目的所有者是 Administrator，而当前用户是pengmude, 那么就会导致上面的错误</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>输入以下命令即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git config --global --add safe.directory &quot;*&quot;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记录docker的一些问题及解决方法</title>
    <link href="/2024/06/22/docker/"/>
    <url>/2024/06/22/docker/</url>
    
    <content type="html"><![CDATA[<h2 id="设置开机自启动"><a href="#设置开机自启动" class="headerlink" title="设置开机自启动"></a>设置开机自启动</h2><p>例如启动一个MySQL容器需要开机自启则使用以下命令启动容器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">#  docker run -d <span class="hljs-attr">--name</span> mysql -<span class="hljs-selector-tag">p</span> <span class="hljs-number">3306</span>:<span class="hljs-number">3306</span> --restart=always<br>always - 无论退出状态是如何，都重启容器<br></code></pre></td></tr></table></figure><p>如果在启动的时候忘记加该参数两个方法实现自启动</p><ol><li>删除容器重新创建</li><li>更新容器<br>下面介绍如何更新<br>更新之前查看容器重启策略</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># docker inspect 521b7fb8f7da|grep -i <span class="hljs-string">&quot;RestartPolicy&quot;</span> -A 2</span><br>            <span class="hljs-string">&quot;RestartPolicy&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>                <span class="hljs-string">&quot;MaximumRetryCount&quot;</span>: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>解析</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># 通过容器id查看容器信息</span><br>docker inspect <span class="hljs-number">521</span>b7fb8f7da<br><span class="hljs-comment"># 管道符</span><br>|<br><span class="hljs-comment"># 通过关键字RestartPolicy匹配容器重启策略</span><br><span class="hljs-keyword">grep</span> -i <span class="hljs-string">&quot;RestartPolicy&quot;</span> <br><span class="hljs-comment"># 除了匹配的关键字还列出关键字下面两行</span><br>-A <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>可以看到重启策略关键字RestartPolicy对应的name为空<br>通过容器ID更新容器重启策略</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"># docker <span class="hljs-keyword">update</span> <span class="hljs-comment">--restart=always 521b7fb8f7da</span><br></code></pre></td></tr></table></figure><p>再次查看容器信息<br>已经设置为总是启动了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># docker inspect 521b7fb8f7da|grep -i <span class="hljs-string">&quot;RestartPolicy&quot;</span> -A 2</span><br>            <span class="hljs-string">&quot;RestartPolicy&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;always&quot;</span>,<br>                <span class="hljs-string">&quot;MaximumRetryCount&quot;</span>: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>如果想要重启不自动启动则使用以下命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"># docker <span class="hljs-keyword">update</span> <span class="hljs-comment">--restart=no 75038d7a530f</span><br></code></pre></td></tr></table></figure><h2 id="docker网络"><a href="#docker网络" class="headerlink" title="docker网络"></a>docker网络</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="docker拉取镜像报错"><a href="#docker拉取镜像报错" class="headerlink" title="docker拉取镜像报错"></a>docker拉取镜像报错</h2><p><strong>报错</strong></p><p> error pulling image configuration: Get <a href="https://production.cloudflare.docker.com/">https://production.cloudflare.docker.com</a></p><p><strong>解决</strong></p><p>能加多少镜像就加多少到&#x2F;etc&#x2F;docker&#x2F;daemon.json文件中，以下是阿里云镜像加速：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mkdir</span> -p /etc/docker<br>sudo <span class="hljs-built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="hljs-string">&#x27;EOF&#x27;</span><br>&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://9rfsxolh.mirror.aliyuncs.com&quot;</span>]<br>&#125;<br>EOF<br>sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><p>还有其他镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;http://hub-mirror.c.163.com&quot;</span>,<br><span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,<br><span class="hljs-string">&quot;https://registry.docker-cn.com&quot;</span>,<br><span class="hljs-string">&quot;http://hub-mirror.c.163.com&quot;</span>,<br><span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,<br><span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,<br><span class="hljs-string">&quot;https://hccwwfjl.mirror.aliyuncs.com&quot;</span><br></code></pre></td></tr></table></figure><p>最新镜像去github上看看</p><p><a href="https://github.com/sky22333/Docker-Hub">sky22333&#x2F;Docker-Hub: Docker Hub镜像加速or项目收集 (github.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记录linux的一些问题及解决方法</title>
    <link href="/2024/06/21/linux/"/>
    <url>/2024/06/21/linux/</url>
    
    <content type="html"><![CDATA[<h2 id="防止IP变化"><a href="#防止IP变化" class="headerlink" title="防止IP变化"></a>防止IP变化</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>​        每次在自己电脑打开VMware，进入Linux时，发现有时候ip会改变，导致传输文件或者远程连接出现问题，每次更改ip都要去更改其它文件相对麻烦。</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>因为虚拟机的ip是动态分配的，是可能存在以下几种原因导致其发生变化：</p><p>主机连接的网络不一样，比如上次连接的是自己手机热点，这次换成网线连接；<br>主机关机，重新开机；<br>卸载VMware，重新导入虚拟机。</p><h3 id="解决（固定ip地址）"><a href="#解决（固定ip地址）" class="headerlink" title="解决（固定ip地址）"></a>解决（固定ip地址）</h3><p><strong>（一）准备工作</strong><br>1.查询虚拟机ip地址</p><p>ifconfig</p><p>2.查询网关ip</p><p>编辑一&gt;虚拟网络编译器一&gt;更改设置一&gt;上方选择NAT模式，下方选择NAT设置一&gt;网关IP</p><p><strong>（二）固定ip</strong><br>位置一&gt;计算机</p><p>进入以下位置<br>etc&#x2F;sysconfig&#x2F;network-scripts</p><p>右键进入终端，并打开虚拟机网卡配置文件 ifcfg-ens33</p><p>vim ifcfg-ens33</p><p>将dhcp更改为static，让IP分配规则静态化，不再改变<br>BOOTPROTO&#x3D;”static”</p><p> 在网卡配置文件的结尾处配置上虚拟机ip地址，网关IP，以及域名解析服务器。<br>IPADDR&#x3D;”自己的IP地址”<br>GATEWAY&#x3D;”自己的网关IP”</p><p>NAS1&#x3D;”同网关IP”</p><p>退出编辑并保存退出<br>Esc一&gt;:wq </p><p>重启网卡</p><p>systemctl restart network</p><p><strong>（三）查看网络是否联通</strong><br>1.本机查看</p><blockquote><p>ping 虚拟机的IP</p></blockquote><p>2.虚拟机查看</p><p>ping 本机IP</p><h2 id="虚拟ip的原理及使用"><a href="#虚拟ip的原理及使用" class="headerlink" title="虚拟ip的原理及使用"></a>虚拟ip的原理及使用</h2><p><a href="https://www.cnblogs.com/jmcui/p/13055283.html">虚拟IP原理及使用 - JMCui - 博客园 (cnblogs.com)</a></p><p><strong>举个通俗的例子</strong></p><p>老王开了一个会所，地址是虹X路1.1.1.1，经营范围不太正规，经常被封，顾客以为店已经关门，其实里面热火朝天，所以老王急啊，于是开了一个后门，地址是2.2.2.1，于是顾客纷纷从后门进入，老王笑开了花…</p><p>过几天大门解封了，但后门由于弄堂改造，临时关闭了，<strong>熟门熟路</strong>的顾客从后门进不来了，有同学会问，大门都开着，顾客为何不从前门进店？因为这些<strong>顾客头脑比较简单</strong>，老王苦啊，痛定思痛，老王想出了一个好主意。</p><p>老王给顾客自己的电话号码<strong>4.4.4.1</strong>，叮嘱他们，以后来店消费之前，只要电话能打通（4.4.4.1路由可达），说明店还营业，前门进不来（1.1.1.1接口down）就走后门（2.2.2.1接口UP)；同理，如果后门进不来，可以走前门。</p><p>如果电话打不通（4.4.4.1路由消失），说明老王被关进去了，顾客就别来了，因为前门被封（1.1.1.1接口down)，后门也被封（2.2.2.1接口down），来了也是白来。</p><p><strong>谈点正经的</strong></p><p>其实电脑上的<strong>127.0.0.1</strong>也是一个VIP，只是用于本机进程间的通信标识符。</p><p>如果没有127.0.0.1，那么一旦物理接口down，TCP&#x2F;IP协议栈绑定在此接口上的IP就无法提供进程间的通信，所以非常不方便。</p><p>而有了127.0.0.1，不管物理接口状态如何，都可以进程间通信。</p><p>题主问题里的VIP，也是不依赖于任何物理接口，只要有一个物理接口处于工作状态（UP，可以和外部联系），就可以提供服务器的访问，当然需要通过路由发布将4.4.4.1发布出去，别的三层设备、主机需要知道如何到达4.4.4.1。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>rabbitMQ</title>
    <link href="/2024/06/19/rabbitMQ%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2024/06/19/rabbitMQ%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="DOCKER安装RABBITMQ教程（详细图文）"><a href="#DOCKER安装RABBITMQ教程（详细图文）" class="headerlink" title="DOCKER安装RABBITMQ教程（详细图文）"></a><a href="https://www.cnblogs.com/csjoz/p/18176355">DOCKER安装RABBITMQ教程（详细图文）</a></h2><p>1.下载Rabbitmq的镜像<br>拉取最新的rabbitmq的镜像</p><p>docker pull rabbitmq<br>拉取指定版本的rabbitmq镜像</p><p>docker pull rabbitmq:版本号<br>2.创建并运行rabbitmq容器<br>docker run -d -p 15673:15672 -p 5674:5672 <br>    –restart&#x3D;always <br>    -e RABBITMQ_DEFAULT_VHOST&#x3D;my_vhost  <br>    -e RABBITMQ_DEFAULT_USER&#x3D;admin <br>    -e RABBITMQ_DEFAULT_PASS&#x3D;admin123456 <br>    –hostname myRabbit <br>    –name rabbitmq-new<br>    rabbitmq:latest<br>注意：在映射的端口号的时候不要映射 5671端口，端口5671是 RabbitMQ 的默认AMQP over TLS&#x2F;SSL端口。AMQP（Advanced Message Queuing Protocol）是一种消息传递协议，用于在应用程序之间进行可靠的消息传递。</p><p>参数说明：</p><p>-d：表示在后台运行容器；<br>-p：将主机的端口 15673（Web访问端口号）对应当前rabbitmq容器中的 15672 端口，将主机的5674（应用访问端口）端口映射到rabbitmq中的5672端口；<br>–restart&#x3D;alawys：设置开机自启动<br>-e：指定环境变量：<br>  RABBITMQ_DEFAULT_VHOST：默认虚拟机名；<br>  RABBITMQ_DEFAULT_USER：默认的用户名；<br>  RABBITMQ_DEFAULT_PASS：默认的用户密码；<br>–hostname：指定主机名（RabbitMQ 的一个重要注意事项是它根据所谓的 节点名称 存储数据，默认为主机名）；<br>–name rabbitmq-new：设置容器名称；<br>查看启动情况</p><p>3.启动web客户端<br>方法一：进入容器开启</p><p>#进入rabbitmq容器<br>docker exec -it 容器名&#x2F;容器id &#x2F;bin&#x2F;bash<br>#开启web客户端<br>rabbitmq-plugins enable rabbitmq_management<br>方法二：不进入容器开启</p><p>docker exec -it 容器名&#x2F;容器id rabbitmq-plugins enable rabbitmq_management<br>4.访问rabbitmq的微博客户端<br>在浏览器上输入 ip+端口 访问rabbitmq的web客户端</p><p>输入上面在初始化Rabbitmq容器时我们自己指定了默认账号和密码：admin&#x2F;admin123456，如果没有指定的话那么rabbitmq的默认账号密码是:guest&#x2F;guest</p><p>登录成功如下图所示：</p><p> 如果提示网页无法访问的话，可检查服务器的防火墙是否开启了这个端口。</p><p>#查看防火墙规则中打开的端口列表<br>firewall-cmd –list-ports<br>#添加端口<br>firewall-cmd –zone&#x3D;public –add-port&#x3D;15673&#x2F;tcp –permanent<br>#重新加载，使配置生效<br>firewall-cmd –reload<br>–zone&#x3D;public 指定了要添加规则的区域（这里是公共区域）<br>–add-port&#x3D;15673&#x2F;tcp 指定了要添加的端口及其协议（这里是 TCP 协议的 15673 端口）<br>–permanent 则表示将规则永久保存，使其在系统重启后仍然有效。<br>5.遇到的问题<br>问题描述：在rabbitmq的web客户端发现界面会弹出如下提示框Stats in management UI are disabled on this node</p><p>解决方法<br>（1）进入到启动的rabbitmq的容器中<br>docker exec -it 容器名称&#x2F;容器id &#x2F;bin&#x2F;bash</p><p>（2）切换到rabbitmq的配置文件目录<br>cd &#x2F;etc&#x2F;rabbitmq&#x2F;conf.d&#x2F;</p><p>（3）修改配置文件- management_agent.disable_metrics_collector.conf<br>echo management_agent.disable_metrics_collector &#x3D; false &gt; management_agent.disable_metrics_collector.conf<br>（4）查看配置文件-cat</p><p>（5）退出容器<br>exit</p><p>（6）重启容器<br> docker restart 容器名称&#x2F;容器id</p><p>再次进入rabbitmq的web客户端页面，点击各个页面就不会出现那个提示，并且出现了统计图表以及可以添加一下展示的信息字段。</p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/06/17/%E7%A7%91%E7%A0%94/%E6%9C%89%E6%8D%9F%E5%8E%8B%E7%BC%A9+%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95/"/>
    <url>/2024/06/17/%E7%A7%91%E7%A0%94/%E6%9C%89%E6%8D%9F%E5%8E%8B%E7%BC%A9+%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="KaiwuDB中的压缩算法"><a href="#KaiwuDB中的压缩算法" class="headerlink" title="KaiwuDB中的压缩算法"></a>KaiwuDB中的压缩算法</h2><img src="./../images/image-20240719130128012.png" alt="image-20240719130128012" style="zoom: 67%;" /><p>实验应该是针对无损压缩进行的。</p><p>TSZ算法是基于数据预测技术的有损压缩，在tdengine中作为可选项，默认不开启，针对浮点数。</p><h2 id="最新版TDengine取消了TSZ"><a href="#最新版TDengine取消了TSZ" class="headerlink" title="最新版TDengine取消了TSZ"></a>最新版TDengine取消了TSZ</h2><p>最新版本取消了lossyColumns参数。</p><p>最新版文档取消了相关内容，旧版文档还可以打开。</p><img src="./../images/image-20240717121213940.png" alt="image-20240717121213940" style="zoom:50%;" /><img src="./../images/image-20240717144836303.png" alt="image-20240717144836303" style="zoom:50%;" /><img src="./../images/image-20240717144948793.png" alt="image-20240717144948793" style="zoom:50%;" /><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>把TDengine中的压缩算法在KaiwuDB中实现，然后哪里有问题再去解决问题。</p><p>目前进展：对TDengine中的压缩算法做了一些使用。</p><p>todo：需要搞懂压缩算法源码，读起来费力。</p><h2 id="TDengine压缩实验"><a href="#TDengine压缩实验" class="headerlink" title="TDengine压缩实验"></a>TDengine压缩实验</h2><p>验证写入数据被 TDengine 存储后再次读取出来的正确性。</p><p><strong>数据准备</strong></p><p>​写入 10 个子表， 每子表 10 万数据，分别写入 float 和 double 字段指定的随机值，写入完成后全部再读取出来，和原来写入时的值进行比较。</p><p><img src="/./../images/image-20240717125329251.png" alt="image-20240717125329251"></p><p>​</p><p><img src="/./../images/image-20240717125234366.png" alt="image-20240717125234366"></p><p>c3和c4由c1和c2计算得来，验证时再读取出来合成一个浮点数进行验证。验证的误差 float 为 1e-6, double 为 1e-12；</p><p><strong>测试步骤</strong></p><ol><li>配置 TSZ 选项为打开 lossyColumns float|double</li><li>启动 taosd</li><li>创建数据库及表，表中包括 float 及 double 字段</li><li>写入 100 万条数据</li><li>写入成功后读取并查看数据正确性</li><li>退出 taosd 并关闭 TSZ 选项</li><li>启动 taosd 并写入新数据到表中</li></ol><p><strong>测试结果显示原来的数据及新写入数据，都正常为符合预期，反复打开及关闭 TSZ，不影响已写入数据的正常存取。</strong></p><h2 id="TDengine中的TSZ压缩算法"><a href="#TDengine中的TSZ压缩算法" class="headerlink" title="TDengine中的TSZ压缩算法"></a>TDengine中的TSZ压缩算法</h2><p>TDengine 支持版本为 3.2.0.0 或以上。默认不开启，可通过修改配置文件开启。</p><img src="../images/image-20240705094845784.png" alt="image-20240705094845784" style="zoom:67%;" /><p><a href="https://docs.taosdata.com/tdinternal/tsz/">TSZ 压缩算法 | TDengine 文档 | 涛思数据 (taosdata.com)</a></p><p><a href="https://www.taosdata.com/tdengine-engineering/22274.html?spm=a2c6h.12873639.article-detail.8.379936780mTq0Q">TDengine Contributor 钟宇讲述 TSZ 压缩算法优化背后的故事 - TDengine | 涛思数据 (taosdata.com)</a></p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>是对SZ压缩算法的改进。</p><img src="../images/image-20240705103113561.png" alt="image-20240705103113561" style="zoom: 67%;" /><h2 id="《Fast-Error-bounded-Lossy-HPC-Data-Compression-with-SZ》"><a href="#《Fast-Error-bounded-Lossy-HPC-Data-Compression-with-SZ》" class="headerlink" title="《Fast Error-bounded Lossy HPC Data Compression with SZ》"></a>《Fast Error-bounded Lossy HPC Data Compression with SZ》</h2><p>2016 IPDPS</p><p>开源</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>针对的是HPC数据，浮点数据。</p><p>显着减小要转储的数据大小，同时保持相当低的计算成本和所需的压缩误差界限。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>三个步骤：</p><p>给定一个 d 维浮点数组，整个压缩过程可以分为三个步骤：</p><p>（1）将 d 维浮点数组转换为一维数组。</p><p>（2）压缩一维数组</p><p>逐一检查一维数组中的每个数据点，看看是否可以通过某种曲线拟合模型。 如果可以，我们记录该点对应的曲线拟合模型。 </p><p>对于数据预测，我们采用三种曲线拟合模型，先行邻域拟合（PNF）、线性曲线拟合（LCF）和二次曲线拟合(QCF)，描述如下：</p><ul><li>PNF</li></ul><p><img src="/../images/image-20240703141812263.png" alt="image-20240703141812263"></p><ul><li>LCF</li></ul><p><img src="/../images/image-20240703141821182.png" alt="image-20240703141821182"></p><ul><li>QCF</li></ul><p><img src="/../images/image-20240703141828188.png" alt="image-20240703141828188"></p><p><img src="/../images/image-20240703142806963.png" alt="image-20240703142806963"></p><p>（3）对于不可压缩的数据点</p><p>无法预测的数据称为不可预测数据，它们将通过分析 IEEE 754 二进制表示进行压缩，然后单独存储。</p><p>简单来说，我们根据用户指定的误差界限和数据值范围推导所需的最小尾数位数，从而可以截断无意义的位。</p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>这一系列trick使得SZ在浮点有损压缩时错误范围限定在10^-4时压缩比可以达到5.4，解压不会超过制定错误范围，且解压较快O(N)。</p><h2 id="《A-Time-Series-Compression-Technique-and-its-Application-to-the-Smart-Grid》"><a href="#《A-Time-Series-Compression-Technique-and-its-Application-to-the-Smart-Grid》" class="headerlink" title="《A Time-Series Compression Technique and its Application to the Smart Grid》"></a><strong>《A Time-Series Compression Technique and its Application to the Smart Grid》</strong></h2><p><strong>VLDB.2014</strong></p><p>本文介绍了一种有损压缩技术，建立在分段回归的基础上，学习不同程度的多项式回归函数。压缩技术保证压缩时间序列中的任何点都不会超过用户定义的与原始值的最大偏差。</p><p><img src="/../images/image-20240620092148893.png" alt="image-20240620092148893"></p><p><strong>压缩方法</strong></p><p>本文的分段回归技术采用贪婪策略来压缩时间序列的间隔。 在内部，我们的技术使用三种在线回归算法，每一个都专门研究以下一类多项式函数：常数函数（零次多项式）、直线函数（一次多项式）和大于或等于二次的多项式。压缩结果取决于用户定义的最大可容忍偏差。</p><img src="../images/image-20240620100703301.png" alt="image-20240620100703301" style="zoom: 80%;" /><p>1.从两点的线段开始，按次数 k 循环多项式回归函数，从 k &#x3D; 0 到 k &#x3D; 2。 根据 k 的值，我们从上面列出的三种算法中采用相应的专用回归算法。</p><p>2.在每一步中，只要使用 k 次多项式函数对当前段的逼近达到精度保证，我们就会将时间序列的下一个点添加到当前段。一旦不再达到精度，我们就暂时保存当前多项式参数和相应近似值已达到精度保证的线段长度。</p><p>3.然后我们传递到下一次多项式并重复该过程。当我们达到最高次数的多项式并且循环无法再以所要求的精度逼近当前段时，循环终止。 然后，我们选择实现最高压缩比的多项式。 </p><p>4.我们通过保存其开始和结束位置以及多项式的系数来压缩相应的段。 然后，刚刚描述的分段压缩过程从下一段开始重新开始。</p><p><strong>回归函数的选择</strong></p><p>本文选择了三种在线回归算法，分别针对不同次数的多项式。</p><p>常数函数：I. Lazaridisand and S. Mehrotra. 2003. Capturing sensor-generated time series with quality guarantees. In Proceedings<br>ofthe 19th International Conference on Data Engineering. 429–440.</p><p>直线函数：M. Dalai and R. Leonardi. 2006. Approximations ofone-dimensional digital signals under thelinftynorm. IEEETrans-<br>actions on Signal Processing 54, 8 (2006), 3111–3124.</p><p>大于或等于二次的多项式：R. Seidel. 1991. Small-dimensional linear programming and convex hulls made easy. Discrete and Computational Ge-ometry 6, 3 (1991), 423–434.</p><p>可以针对具体的数据集选择更合适的函数，比如正弦函数等。</p><p><strong>如何存储压缩数据</strong></p><p>将压缩数据存储在关系数据库系统中</p><p><img src="/../images/image-20240620170314345.png" alt="image-20240620170314345"></p><p><strong>参数</strong></p><p>允许的最大偏差、最大多项式次数</p><p><strong>实验</strong></p><p>准确性、压缩、性能</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>桥接模式、nat模式和主机模式</title>
    <link href="/2024/06/17/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/06/17/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>虚拟机可以和外部系统通讯，但会浪费宿主的ip</p><img src="../images/image-20240711200106245.png" alt="image-20240711200106245" style="zoom: 50%;" /><h2 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a>NAT模式</h2><p>虚拟机互通、可以和外部通讯，但用的不是同一个网段；外部不可以和虚拟器通讯</p><p><img src="/../images/image-20240711201909422.png" alt="image-20240711201909422"></p><h2 id="内部网络"><a href="#内部网络" class="headerlink" title="内部网络"></a>内部网络</h2><p>虚拟机之间可以互相通讯，但和外部无联系</p><p><img src="/../images/image-20240711195727113.png" alt="image-20240711195727113"></p><h2 id="仅主机模式"><a href="#仅主机模式" class="headerlink" title="仅主机模式"></a>仅主机模式</h2><p>独立系统，不和外部发生联系</p><img src="../images/image-20240711202304552.png" alt="image-20240711202304552" style="zoom:50%;" /><h2 id="docker中的网络"><a href="#docker中的网络" class="headerlink" title="docker中的网络"></a>docker中的网络</h2><p>默认情况下，所有容器都是以bridge方式连接到Docker的一个虚拟网桥上：</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>云服务器端口不能使用的问题</title>
    <link href="/2024/06/11/%E7%9F%AD%E9%93%BE%E6%8E%A5/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%A3%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/06/11/%E7%9F%AD%E9%93%BE%E6%8E%A5/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%A3%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="云服务器端口不能使用"><a href="#云服务器端口不能使用" class="headerlink" title="云服务器端口不能使用"></a>云服务器端口不能使用</h2><p>本人在部署短链接过程中，所以需要开启某个端口，遇到以下两种端口情况，希望能帮助到你！</p><h3 id="1-首先需要去阿里云服务器中开放端口"><a href="#1-首先需要去阿里云服务器中开放端口" class="headerlink" title="1.首先需要去阿里云服务器中开放端口"></a>1.首先需要去阿里云服务器中开放端口</h3><p>安全组中：</p><p><img src="/../images/image-20240611140843963.png" alt="image-20240611140843963"></p><h3 id="2-除了上述端口开启完，你还需要让这个端口在终端可以使用！"><a href="#2-除了上述端口开启完，你还需要让这个端口在终端可以使用！" class="headerlink" title="2.除了上述端口开启完，你还需要让这个端口在终端可以使用！"></a>2.除了上述端口开启完，你还需要让这个端口在终端可以使用！</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用这个命令查看，端口开放的情况，是否由于该端口已被占用</span><br>ss -tuln | grep :80<br></code></pre></td></tr></table></figure><p>若上述没有查找到指定端口被占用，并且端口也没有开放，则使用如下命令，因为阿里云服务器除了在安全组开放外，还要在服务器防火墙手动开启，<strong>除非你禁用服务器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 如，我需要开启8888端口</span><br><span class="hljs-comment"># 即命令 iptables -I INPUT -m state --state NEW -m tcp -p tcp --dport 8888 -j ACCEPT</span><br>iptables -I INPUT -m state --state NEW -m tcp -p tcp --dport 端口 -j ACCEPT<br>iptables -I INPUT -m state --state NEW -m udp -p udp --dport 端口 -j ACCEPT<br> <br><span class="hljs-comment"># 删除防火墙规则，内容一样把 -I 换成 -D 就行了：</span><br>iptables -D INPUT -m state --state NEW -m tcp -p tcp --dport 端口 -j ACCEPT<br>iptables -D INPUT -m state --state NEW -m udp -p udp --dport 端口 -j ACCEPT<br></code></pre></td></tr></table></figure><h3 id="常用的操作端口的命令"><a href="#常用的操作端口的命令" class="headerlink" title="常用的操作端口的命令"></a><strong>常用的操作端口的命令</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">查看端口是否开启：<br>ss -tuln | grep :80<br><br>查看某端口上的进程：<br>lsof -i :5127<br></code></pre></td></tr></table></figure><p>测试端口是否开启的网站：</p><p><a href="https://tool.chinaz.com/port">端口扫描 - 站长工具 (chinaz.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>短链接</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DDD架构</title>
    <link href="/2024/06/10/%E5%A4%A7%E8%90%A5%E9%94%80%E9%A1%B9%E7%9B%AE/DDD%E6%9E%B6%E6%9E%84/"/>
    <url>/2024/06/10/%E5%A4%A7%E8%90%A5%E9%94%80%E9%A1%B9%E7%9B%AE/DDD%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="DDD架构"><a href="#DDD架构" class="headerlink" title="DDD架构"></a>DDD架构</h2><p><a href="https://bugstack.cn/md/road-map/ddd.html">DDD 架构 | 小傅哥 bugstack 虫洞栈</a></p><p><a href="https://www.bilibili.com/video/BV1kV411g7GX/?t=44.614722&spm_id_from=333.1350.jump_directly&vd_source=08b017bec121a20e81681bf601db9437">架构的本质之DDD架构 —— Java简明教程，一套简单、清晰、明了的Java学习路线资料！！！_哔哩哔哩_bilibili</a></p><h3 id="VO和Entity的区别"><a href="#VO和Entity的区别" class="headerlink" title="VO和Entity的区别"></a>VO和Entity的区别</h3><ul><li>Entity在整个生命周期中，有多个「状态」，也就是说「状态」是可变的（至于变不变就看实际情况了） </li><li>而VO在整个生命周期中，只有一个「状态」，也就是说「状态」不变</li></ul><p><strong>如何识别</strong></p><p>一个对象是表示成Entity还是VO，取决于系统的关注点</p><p>举个例子：</p><p>「商品」在「订单系统」中是个VO，而在「商品管理系统」中是Entity</p><ul><li>在「商品管理系统」中，系统需要关注「商品」的「状态」，需要维护是否上架、库存多少、各种属性等信息（多种状态）。就是说在「商品管理系统」中，商品状态是可变的。所以它也有「标识」，即商品ID</li><li>「订单系统」并不关心「商品」的「状态」变化，它只关注在创建订单时，这个「商品」的当前「状态」是什么，并且在订单创建完成后，这个「商品」的「状态」就不会再改变了</li></ul><h2 id="聚合对象"><a href="#聚合对象" class="headerlink" title="聚合对象"></a>聚合对象</h2><p>一般用在事务</p>]]></content>
    
    
    <categories>
      
      <category>抽奖系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>短链接云服务器项目部署</title>
    <link href="/2024/06/09/%E7%9F%AD%E9%93%BE%E6%8E%A5/%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    <url>/2024/06/09/%E7%9F%AD%E9%93%BE%E6%8E%A5/%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="云服务器"><a href="#云服务器" class="headerlink" title="云服务器"></a>云服务器</h1><p>购买阿里云2c4g服务器；</p><p>开放相应端口；</p><h1 id="基础环境安装"><a href="#基础环境安装" class="headerlink" title="基础环境安装"></a>基础环境安装</h1><h2 id="jdk"><a href="#jdk" class="headerlink" title="jdk"></a>jdk</h2><p>进入 <code>/usr/local</code> 目录，创建 java 文件夹。并将 JDK17 上传到 java 目录下。</p><p>上传成功后，解压 JDK17 压缩包，命令 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip zulu17.44.53-ca-jdk17.0.8.1-linux_x64.zip<br></code></pre></td></tr></table></figure><p>另外执行一条命令，修改文件名，让它看着没那么长：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> zulu17.44.53-ca-jdk17.0.8.1-linux_x64 jdk17.0.8.1<br></code></pre></td></tr></table></figure><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum update<br>sudo yum install nginx<br>sudo systemctl start nginx<br>sudo systemctl <span class="hljs-built_in">enable</span> nginx<br></code></pre></td></tr></table></figure><h1 id="项目打包上传"><a href="#项目打包上传" class="headerlink" title="项目打包上传"></a>项目打包上传</h1><p>通过命令创建短链接相关文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /home/shortlink/logs<br></code></pre></td></tr></table></figure><h2 id="1-聚合-网关项目"><a href="#1-聚合-网关项目" class="headerlink" title="1. 聚合&amp;网关项目"></a>1. 聚合&amp;网关项目</h2><p>shortlink-all 下执行 <code>mvn clean install</code></p><p>将 <code>aggregation-service</code> 还有网关服务 <code>gateway-service</code> 上传到服务器 <code>/home/shortlink</code> 目录下。</p><h2 id="2-前端项目"><a href="#2-前端项目" class="headerlink" title="2.前端项目"></a>2.前端项目</h2><p>进入到 <code>console-vue</code> 目录下，执行 <code>npm run build</code> 命令。</p><p>将该 dist 目录上传到云服务器 <code>/home/shortlink</code> 目录下。上传前记得压缩下 dist 目录，上传方便些，上传成功后再解压。</p><h1 id="中间件安装"><a href="#中间件安装" class="headerlink" title="中间件安装"></a>中间件安装</h1><p>docker、mysql、redis、nacos</p><p>网上有教程</p><h1 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h1><h2 id="1-后端项目"><a href="#1-后端项目" class="headerlink" title="1.后端项目"></a>1.后端项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">后端项目<br><span class="hljs-built_in">nohup</span> /usr/local/java/jdk17.0.8.1/bin/java \<br>-Dshort-link.domain.default=120.26.138.90:8003 \<br>-jar /home/shortlink/shortlink-aggregation.jar &gt; logs/shortlink-aggregation.file 2&gt;&amp;1 &amp;<br><br>网关项目<br><span class="hljs-built_in">nohup</span> /usr/local/java/jdk17.0.8.1/bin/java \<br>-jar /home/shortlink/shortlink-gateway.jar &gt; logs/shortlink-gateway.file 2&gt;&amp;1 &amp;<br></code></pre></td></tr></table></figure><p><strong>查看是否启动成功</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#聚合项目</span><br><span class="hljs-built_in">tail</span> -f logs/shortlink-aggregation.file<br><br><span class="hljs-comment">#网关项目</span><br><span class="hljs-built_in">tail</span> -f logs/shortlink-gateway.file<br></code></pre></td></tr></table></figure><p><strong>查看服务状态</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -ef | grep java<br><br><span class="hljs-comment">#关闭服务</span><br><span class="hljs-built_in">kill</span> -9 [进程号]<br></code></pre></td></tr></table></figure><h2 id="2-nginx挂载前端项目"><a href="#2-nginx挂载前端项目" class="headerlink" title="2.nginx挂载前端项目"></a>2.nginx挂载前端项目</h2><p>修改 Nginx 的配置，让前端可以访问。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /etc/nginx/nginx.conf<br></code></pre></td></tr></table></figure><p>将默认 Nginx <code>http/server</code>配置改为下述配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">http &#123;<br>    <span class="hljs-comment"># 只要保证 server 里的配置在 nginx 的 http 配置下就好</span><br>server &#123;<br>        listen       80;<br>        server_name  localhost;<br><br>         location / &#123;<br>            root   /home/shortlink/dist;<br>            index  index.html index.htm;<br>            try_files <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ /index.html;<br>        &#125;<br><br>        location /api &#123;<br>            proxy_read_timeout 10s;<br>            proxy_pass http://127.0.0.1:8000/api;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重启nginx。</p><h1 id="公网访问"><a href="#公网访问" class="headerlink" title="公网访问"></a>公网访问</h1><p>浏览器访问：<code>http://公网IP</code> 即可看到对应的前端页面。</p>]]></content>
    
    
    <categories>
      
      <category>短链接项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式的总结</title>
    <link href="/2024/06/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/06/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。策略模式让算法独立于使用它的客户而变化，比如以下例子：</p><img src="../images/image-20240609111329679.png" alt="image-20240609111329679" style="zoom:50%;" /><p>类图</p><img src="../images/image-20240609111416047.png" alt="image-20240609111416047" style="zoom: 50%;" /><h3 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h3><p>线程池构造方法中指定拒绝策略，指定不同的拒绝策略，相当于选择不同的策略。</p><h3 id="我们的项目中"><a href="#我们的项目中" class="headerlink" title="我们的项目中"></a><strong>我们的项目中</strong></h3><p>ILogicFilter</p><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>记录nginx的一些配置</title>
    <link href="/2024/06/09/nginx%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2024/06/09/nginx%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#启动脚本是在</span><br>/usr/local/nginx/sbin/nginx<br><span class="hljs-comment">#启动,</span><br>/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf<br><span class="hljs-comment">#停止</span><br>/usr/local/nginx/sbin/nginx -s stop<br><span class="hljs-comment">#重载</span><br>/usr/local/nginx/sbin/nginx -s reload<br><span class="hljs-comment">#杀掉nginx</span><br>/usr/local/nginx/sbin/nginx -s quit<br></code></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2>]]></content>
    
    
    <categories>
      
      <category>nginx</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/06/08/%E7%AE%97%E6%B3%95/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <url>/2024/06/08/%E7%AE%97%E6%B3%95/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="6-9戳气球"><a href="#6-9戳气球" class="headerlink" title="6.9戳气球"></a>6.9戳气球</h3><p>记忆化搜索或者动态规划</p><h3 id="6-10"><a href="#6-10" class="headerlink" title="6.10"></a>6.10</h3><p>简单的双指针，但想不到。</p><h3 id="6-11"><a href="#6-11" class="headerlink" title="6.11"></a>6.11</h3><p>简单题，但没做出来</p><p>二分查找的变体，看灵神的总结</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo初学第一天</title>
    <link href="/2024/06/08/hexo/hexo%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <url>/2024/06/08/hexo/hexo%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<p>配置hexo环境，并推送到github上。</p><p>详细过程参考如下地址：</p><p><a href="https://www.bilibili.com/video/BV1Yb411a7ty/?spm_id_from=333.880.my_history.page.click">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo初学第二天</title>
    <link href="/2024/06/08/hexo/hexo%E7%AC%AC%E4%BA%8C%E5%A4%A9/"/>
    <url>/2024/06/08/hexo/hexo%E7%AC%AC%E4%BA%8C%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<h3 id="每次修改后需要做的"><a href="#每次修改后需要做的" class="headerlink" title="每次修改后需要做的"></a>每次修改后需要做的</h3><p>完成任意配置后,输入以下指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></td></tr></table></figure><p>在本地localhost:4000 预览效果。然后运行以下命令推送到github</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo d<br></code></pre></td></tr></table></figure><h3 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h3><p>1.在source文件夹下创建images文件夹，以后所有的图片都放这边。</p><p>2.需要将typora中图片显示修改为相对位置才行。</p><h3 id="Front-matter的设置"><a href="#Front-matter的设置" class="headerlink" title="Front-matter的设置"></a>Front-matter的设置</h3><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Hello</span> <span class="hljs-string">World</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2013</span><span class="hljs-string">/7/13</span> <span class="hljs-number">20</span><span class="hljs-string">:46:25</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>常用参数见<a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter | Hexo</a></p><h3 id="主题修改（以fluid主题为例）"><a href="#主题修改（以fluid主题为例）" class="headerlink" title="主题修改（以fluid主题为例）"></a>主题修改（以fluid主题为例）</h3><p>1.使用npm安装主题</p><p>2.创建新的_config.fluid.yml配置文件</p><p>3.在_config.yml文件中修改theme配置</p><p>4.重新加载</p><p>参考地址：<a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid-dev&#x2F;hexo-theme-fluid: :ocean: 一款 Material Design 风格的 Hexo 主题 &#x2F; An elegant Material-Design theme for Hexo (github.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>redis的一些配置问题</title>
    <link href="/2024/06/07/redis%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/06/07/redis%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="redis取消密码"><a href="#redis取消密码" class="headerlink" title="redis取消密码"></a>redis取消密码</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>docker exec -it 027e redis-cli</p><p>AUTH 现有密码</p><p>config set requirepass ‘’</p><p>使用SAVE命令保存更改</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>永久取消密码要去redis.config中设置。</p><p>官方的Redis镜像默认是没有配置文件的。</p><p><a href="https://blog.51cto.com/u_16213420/10677688">redis容器没有配置文件_mob64ca12edad02的技术博客_51CTO博客</a></p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
