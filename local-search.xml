<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C项目的编译</title>
    <link href="/2024/07/29/C/gcc/"/>
    <url>/2024/07/29/C/gcc/</url>
    
    <content type="html"><![CDATA[<p>最近需要跑一个C的项目，C项目编译过程：</p><h1 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h1><p><strong>预处理——编译——汇编——链接</strong></p><p>只编译不链接，生成.o</p><p>gcc -c main.c</p><p>进行链接</p><p>gcc -o main main.o</p><h2 id="多个文件编译"><a href="#多个文件编译" class="headerlink" title="多个文件编译"></a>多个文件编译</h2><p>一个.c文件中用到了其他.c的内容</p><p>编译时需要注意顺序，一般先把多个.c文件编译为.o文件，然后再gcc -o组合起来。</p><p><img src="/../../images/image-20240729190253623.png" alt="image-20240729190253623"></p><p>但是文件多的时候，就需要makefile了。</p><h1 id="找不到头文件的目录"><a href="#找不到头文件的目录" class="headerlink" title="找不到头文件的目录"></a>找不到头文件的目录</h1><p>gcc -I指定</p><h1 id="静态链接库"><a href="#静态链接库" class="headerlink" title="静态链接库"></a>静态链接库</h1><p>把一堆.o文件组织到一起形成.a文件</p><p>命名：lib+库名+.a</p><p>ar命令生成静态链接库</p><p><strong>使用静态链接库</strong></p><p><img src="/../../images/image-20240729191652598.png" alt="image-20240729191652598"></p><p>链接时把库加后面</p><h1 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h1><p>Windows：.dll文件；linux：.so文件</p><p><img src="/../../images/image-20240729192534567.png" alt="image-20240729192534567"></p><h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><p>当.c文件特别多时，gcc编译显得吃力。makefile可以帮忙。</p><h1 id="Cmake"><a href="#Cmake" class="headerlink" title="Cmake"></a>Cmake</h1><p>当makefile也过于复杂时，引出cmake工具，帮我们生成makefile。</p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>抽奖系统未来的可拓展的功能</title>
    <link href="/2024/07/25/%E5%A4%A7%E8%90%A5%E9%94%80%E9%A1%B9%E7%9B%AE/%E6%9C%AA%E6%9D%A5%E7%9A%84%E5%8F%AF%E6%8B%93%E5%B1%95%E7%9A%84%E5%8A%9F%E8%83%BD/"/>
    <url>/2024/07/25/%E5%A4%A7%E8%90%A5%E9%94%80%E9%A1%B9%E7%9B%AE/%E6%9C%AA%E6%9D%A5%E7%9A%84%E5%8F%AF%E6%8B%93%E5%B1%95%E7%9A%84%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<p>未来抽奖系统需要添加的功能：</p><h1 id="分布式动态配置活动降级"><a href="#分布式动态配置活动降级" class="headerlink" title="分布式动态配置活动降级"></a>分布式动态配置活动降级</h1><h2 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h2><p>基于 Zookeeper 实现分布式动态配置中心服务，用于分布式应用节点系统中的环境属性值变更。</p><p>我们设置一个开关，当其打开时，所有服务节点正常工作；当其关闭时，所有抽奖服务做活动降级处理，停止服务。</p><p><img src="/../../images/image-20240715193725238.png" alt="image-20240815193725238"></p><h1 id="分库分表同步ES"><a href="#分库分表同步ES" class="headerlink" title="分库分表同步ES"></a>分库分表同步ES</h1><p>对于C端的场景来说，我们经常会采用分库分表的方案承载数据流量的压力，以用户ID为切分键，让用户的行为数据分散到各个库表中。那么在C端除了给用户提供数据服务以外，还需要给运营提供数据，但分库分表后的数据都已经散列到各个库表了，对于聚合查询就变得复杂，所以我们还需要另外一套方案。就是把分散在各个数据库表的数据，通过使用 canal 组件，基于 binlog 日志，把数据同步到 ElasticSearch 文件服务中再提供使用。</p><p><img src="/../../images/image-20240715194120283.png" alt="image-20240815194120283"></p><h1 id="分布式任务调度引入"><a href="#分布式任务调度引入" class="headerlink" title="分布式任务调度引入"></a>分布式任务调度引入</h1><p>分布式环境下，@Scheduled注解就不再适用，需要引入分布式任务调度组件xxjob。</p><p><img src="/../../images/image-20240715194301798.png" alt="image-20240715194301798"></p>]]></content>
    
    
    <categories>
      
      <category>抽奖系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浪潮实习——两种预计算推荐算法的总结</title>
    <link href="/2024/07/25/%E7%A7%91%E7%A0%94/%E6%B5%AA%E6%BD%AE%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2024/07/25/%E7%A7%91%E7%A0%94/%E6%B5%AA%E6%BD%AE%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="面向时序数据库的预计算推荐系统"><a href="#面向时序数据库的预计算推荐系统" class="headerlink" title="面向时序数据库的预计算推荐系统"></a>面向时序数据库的预计算推荐系统</h1><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>随着数据量的激增，时序数据库在面对复杂查询分析时，往往效率不高。为了解决该问题，预计算发挥着重要作用，因为它可以将复杂查询的结果持久化存储，为后续查询省去了重新计算的时间。然而，当前所有时序数据库都需要用户手动去创建预计算，需要对具体场景有较为深入的理解，对普通用户极为不友好。因此本文设计了面向时序数据库的预计算推荐系统，自动分析数据库中的负载信息，并根据基于规则和基于收益两种算法自动为用户推荐合适的预计算，以提升数据库的查询性能，减少用户的响应时间。实验表明该方案相比于传统的预计算推荐方案能够带来更高的查询效率的提升。</p><h1 id="1、引言"><a href="#1、引言" class="headerlink" title="1、引言"></a>1、引言</h1><p>时间序列数据是指按照时间顺序记录的数据点，它们在许多领域中都非常常见，例如金融交易记录、气象监测数据、工业设备传感器数据等。时序数据普遍具有产生频率高、数据规模大的特点，例如，三一重工在生产的每台重型机械上安装了多种类型的传感器以搜集各种参数，如机械的开关信号、GPS信息、发动机参数等，用以监控重型机械的运转情况[1]。时序数据库（Time Series Database， TSDB）是专为处理此类时间序列数据而设计的数据库系统，它们在时序数据的存储、查询和分析方面具有独特的优势，这些数据库在工业物联网、数字能源、金融等多个领域都已成功完成落地实践，特别适用于处理大规模的时序数据。</p><p>然而近年来，随着信息技术的快速发展，各个领域的数据量正以前所未有的速度增长，比如在工业物联网中，各种设备和传感器产生的时序数据正在爆炸式地增长，给数据查询和分析带来了巨大的挑战。当用户在进行大规模的复杂查询分析时，处理速度往往显著下降，进而极大的影响了用户的体验。因此，优化数据库的查询性能，提高数据处理效率，已成为当前时序数据库技术发展的关键方向。</p><p>为了解决上述问题，时序数据库针对复杂查询分析进行了优化，主要分为三种方法，分别是分布式架构、索引优化和预计算。（1）分布式架构：分布式时序数据库通过分布式计算和存储，提高了处理大规模数据集的能力，优化了复杂查询的性能；（2）索引优化：通过采用特定的索引结构，如时间索引、标签索引等，以提高查询效率。（3）预计算：预计算技术可以将复杂查询的结果持久化存储，从而在查询时直接使用，当查询可以匹配相应的预计算时，可以直接利用已有的结果，省去了重新计算的时间。</p><p>分布式架构和索引优化相比于预计算，存在几个潜在的缺点，在查询执行时仍然无可避免地需要对已有数据进行大量计算，这可能导致查询响应时间较长，尤其是在数据量巨大的情况下。相比之下，预计算技术具有很多好处：（1）快速响应时间：预计算通过预先计算和存储查询结果，能够显著减少查询响应时间。当查询被执行时，可以直接从预计算的结果中获取数据，而不是实时计算，这在数据量非常大时尤其有价值。（2）支持高并发：预计算结果可以被多个用户共享，这意味着系统可以同时处理更多的查询请求，提高了并发处理能力。（3）灵活性和扩展性：预计算技术可以与现有的分布式架构和索引优化技术一起使用，提供更灵活的数据处理和查询能力。然而当前所有时序数据库都需要用户手动去创建预计算，需要用户对具体场景有较为深入的理解，对于普通用户极为不友好。</p><p>本文旨在设计一种面向时序数据库的预计算推荐系统，自动收集并分析数据库中的负载信息，并提出基于规则和基于收益两种预计算推荐算法为用户推荐合适的预计算：基于规则的算法采用贪心策略进行推荐；基于收益的算法采用深度学习的方法精确估计预计算的收益进行推荐，推荐的预计算可以提升数据库的查询性能，减少用户的响应时间。本文的主要贡献如下：</p><ul><li><p>我们设计了一种面向时序数据库的预计算推荐系统。</p></li><li><p>我们设计了一种基于规则的预计算推荐算法，采用贪心的思想，使得推荐的一个预计算尽可能匹配更多的查询。</p></li><li><p>我们设计了一种基于收益的预计算推荐算法，采用深度学习的方法对预计算的收益进行估计，并建模为整数规划问题，使得推荐的预计算在存储空间受限的场景下最大化查询效率，从而解决基于规则的预计算推荐算法在存储空间受限的场景下不适用的问题。</p></li><li><p>我们进行了大量实验验证了本文的预计算推荐算法相比于传统预计算推荐算法在提高查询性能方面的优越性。</p></li></ul><p>本文的其余部分组织如下。在第二节中，我们介绍了相关的工作。在第三节中，我们对相关问题进行了定义。在第四节中，我们提出了我们的预计算推荐算法。在第五节给出了实验结果。我们得出的结论在第六节。</p><h1 id="2、相关工作"><a href="#2、相关工作" class="headerlink" title="2、相关工作"></a>2、相关工作</h1><p>当前所有时序数据库都针对复杂查询分析进行了优化，主要分为三种方法，分别是分布式架构、索引优化和预计算。</p><p>（1）分布式架构：TimescaleDB[6]扩展了PostgreSQL，通过超级表（Hypertables）实现分区和分片。每个Hypertable可以分成多个块（Chunk），这些Chunk可以分布在不同的节点上。当进行查询时，利用PostgreSQL的并行查询能力，TimescaleDB可以在多个节点上并行执行查询操作，从而提高查询性能。TDengine[7]将数据按照时间范围进行分片，每个分片存储在不同的数据节点上。通过这种方式，查询操作可以并行地在多个分片上执行，从而提高查询速度。分片机制能够有效减少单个节点的负载，避免查询瓶颈。</p><p>（2）索引优化：InfluxDB[5]主要通过时间戳索引来加速时间范围查询。时间戳是所有数据点的关键属性，查询通常基于时间范围进行。除了时间戳索引，还使用了标签来标识数据点的属性，标签索引可以加速基于标签的过滤查询。标签是键值对形式，可以用于高效查询和聚合。TDengine同样使用了多级索引结构，包括时间索引和标签索引，以加速时间范围查询和标签过滤查询。</p><p>（3）预计算：OpenTSDB[4]中实现了Rollup和Pre-aggregates，Rollup是一种数据汇总技术，它可以将原始的高分辨率数据按照一定的规则进行聚合，生成低分辨率的数据。这样做的好处是可以减少存储需求，提高查询性能，并且可以更好地处理大规模的时间序列数据。Rollup可以按照时间间隔（例如每小时、每天、每周等）来进行数据聚合，也可以按照指定的标签（例如按照不同的设备、地区等）来进行聚合。Pre-Aggregates是一种预先计算并存储好的聚合数据，在OpenTSDB中，用户可以通过定义预先计算的聚合函数（例如求和、平均值、最大值、最小值等）和时间间隔来创建Pre-Aggregates。一旦创建了Pre-Aggregates，系统就会在后台定期计算并存储好这些聚合数据，用户可以在查询时直接使用这些预先计算好的聚合数据，而不需要实时计算。这样可以大大提高查询性能，并且可以降低对底层存储的压力。InfluxDB支持CQ(continous query)的功能，CQ通过定期 pull 原始时序数据进行计算，将计算结果存储在内部特殊metric 中。用户通过创建 CQ 来实现对数据预处理。TDengine中实现了SMA索引，即Small Materialized Aggregates，提供基于数据块的自定义预计算功能。如果查询处理涉及整个数据块的全部数据，直接使用预计算结果，完全不需要读取数据块的内容。由于预计算数据量远小于磁盘上存储的数据块数据的大小，对于磁盘 I&#x2F;O 为瓶颈的查询处理，使用预计算结果可以极大地减小读取 I&#x2F;O 压力，加速查询处理的流程。</p><p>然而，分布式架构和索引优化在查询执行时仍然无可避免地需要对已有数据进行大量计算，导致查询响应时间较长。相比之下，预计算技术具有很多好处，通过预先计算和存储查询结果避免了大量计算。但是，预计算都需要用户手动生成，需要用户对具体场景有较为深入的理解，对于普通用户极为不友好。因此我们设计了一种面向时序数据库的预计算推荐系统，自动分析数据库中的负载信息，并根据基于规则和基于收益两种算法自动为用户推荐合适的预计算，以提升数据库的查询性能，减少用户的响应时间。</p><h1 id="3-问题定义"><a href="#3-问题定义" class="headerlink" title="3.问题定义"></a>3.问题定义</h1><h2 id="3-1查询和预计算"><a href="#3-1查询和预计算" class="headerlink" title="3.1查询和预计算"></a>3.1查询和预计算</h2><p>时序数据库中的查询带有特有的时间信息，查询语句主要由以下几点构成：时间间隔，聚合函数，时间范围。以如下KaiwuDB中的一条普通查询为例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> time_bucket(k_timestamp, <span class="hljs-string">&#x27;60s&#x27;</span>) <span class="hljs-keyword">as</span> k_timestamp, <span class="hljs-built_in">max</span>(usage_user)<br><span class="hljs-keyword">FROM</span> cpu<br><span class="hljs-keyword">WHERE</span> k_timestamp <span class="hljs-operator">&gt;=</span> <span class="hljs-string">&#x27;2023-01-01 00:00:00&#x27;</span> <span class="hljs-keyword">AND</span> k_timestamp <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;2023-01-06 00:00:00&#x27;</span> <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> time_bucket(k_timestamp, <span class="hljs-string">&#x27;60s&#x27;</span>);<br></code></pre></td></tr></table></figure><p>该查询是指在cpu这张表上，在时间范围为[2023-01-01 00:00:00，2023-01-06 00:00:00]内，每隔时间间隔60s，生成usage_user列上的max聚合结果。</p><p>预计算语句类似于查询语句，不同的地方在于预计算语句无需指定时间范围，它会自动在表上进行预计算任务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> time_bucket(k_timestamp, <span class="hljs-string">&#x27;60s&#x27;</span>) <span class="hljs-keyword">as</span> k_timestamp, <span class="hljs-built_in">max</span>(usage_user)<br><span class="hljs-keyword">FROM</span> cpu<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> time_bucket(k_timestamp, <span class="hljs-string">&#x27;60s&#x27;</span>);<br></code></pre></td></tr></table></figure><p>该预计算语句是指在cpu这张表上进行预计算任务，即每隔时间间隔60s对usage_user列进行max聚合计算。</p><h2 id="3-2预计算匹配"><a href="#3-2预计算匹配" class="headerlink" title="3.2预计算匹配"></a>3.2预计算匹配</h2><p>第 i 条查询 q_i 可以匹配到第 j 条预计算 p_j 的条件是：q_i 的聚合函数集合 g_i 是 p_j 聚合函数集合 g_j 的子集，并且 q_i 的时间间隔 I_i 要为 p_j 时间间隔 I_j 的整数倍，即:</p><p><img src="/../../images/image-20240716102133851.png" alt="image-20240816102133851"></p><h2 id="3-3预计算收益和成本"><a href="#3-3预计算收益和成本" class="headerlink" title="3.3预计算收益和成本"></a>3.3预计算收益和成本</h2><p>第 j 条预计算 p_j 能够为第 i 条查询 q_i 带来的收益为 B_i,j，即 q_i 的原始查询时间 t_i 减去该查询匹配预计算 p_j 的查询时间 t_i,j。  p_j  的成本 c_j 为其本身所占有的存储空间。</p><h2 id="3-4整数规划问题求解器"><a href="#3-4整数规划问题求解器" class="headerlink" title="3.4整数规划问题求解器"></a>3.4整数规划问题求解器</h2><p>Gurobi是由美国Gurobi Optimization公司开发新一代大规模优化器。无论在生产制造领域，还是在金融、保险、交通、服务等其他各种领域，当实际问题越来越复杂，问题规模越来越庞大的时候，需要一个经过证明可以信赖的大规模优化工具，为决策提供质量保证。在理论和实践中，Gurobi优化工具都被证明是全球性能领先的大规模优化器，具有突出的性价比，可以为客户在开发和实施中极大降低成本。</p><p>应用最广泛的数学规划问题类型包括：混合整数线性规划（MILP）、混合整数二次凸规划（MIQP&#x2F;MIQCQP）、混合整数非线性规划等。Gurobi 是唯一一个可以适用上述全部类型，并且在每一个类型中都排名第一，并且大幅度领先第二名的优化器。第三方评比报告做出了明确说明[1]。</p><h1 id="4、预计算推荐系统的整体架构"><a href="#4、预计算推荐系统的整体架构" class="headerlink" title="4、预计算推荐系统的整体架构"></a>4、预计算推荐系统的整体架构</h1><p>在本节中，我们介绍了面向时序数据库的预计算推荐系统的整体架构，主要分为三个部分，如图1所示，包括数据采集、负载分析和预计算推荐三个部分。在数据采集和负载分析中，我们采集相应的数据并对数据进行分析，从而理解数据库的使用模式和用户行为，为预计算推荐算法做支撑。在预计算推荐中，我们首先实现了一种基于规则的预计算推荐算法，该算法采用贪心的思想为用户推荐出相应的预计算以提升数据库的运行效率。接着，为了克服基于规则的预计算推荐算法在存储空间受限的场景下不适用的缺点，我们又提出了基于收益的预计算推荐算法，采用深度学习的方法对预计算收益进行估计，实现了更好的推荐效果。</p><p> <img src="/../../images/image-20240804132244736.png" alt="image-20240804132244736"></p><h2 id="4-1数据采集"><a href="#4-1数据采集" class="headerlink" title="4.1数据采集"></a>4.1数据采集</h2><p>数据采集是预计算推荐系统中的入口，负责采集数据库中的历史负载信息  和预计算元信息  ，如图2所示。这些信息的收集对于深入理解数据库的使用模式、用户行为以及优化查询性能至关重要。</p><p>采集的信息可以分为两类：（1）历史负载信息  ：历史负载信息主要是用户的查询SQL记录，通过对历史负载信息的分析，系统能够识别出常见的查询模式和用户偏好，这对于设计好的预计算推荐算法而言至关重要。（2）预计算元信息  ：预计算元信息提供了对预计算使用情况的全面视图，包括预计算的使用次数、最近使用时间、资源消耗情况等基本信息。使用次数能够反映预计算的活跃度和用户依赖程度；最近使用时间则有助于识别那些可能已经过时或不再符合当前查询需求的预计算；资源消耗情况，如CPU时间、内存使用量和I&#x2F;O操作，能够揭示预计算对系统资源的实际影响，为资源管理和性能调优提供依据。</p><p>数据采集的深度和广度直接影响着预计算推荐系统的性能和效果。通过持续的数据采集和分析，系统能够不断进化，更好地服务于用户。</p><p>  <img src="/../../images/image-20240804132300145.png" alt="image-20240804132300145"></p><h2 id="4-2负载分析"><a href="#4-2负载分析" class="headerlink" title="4.2负载分析"></a>4.2负载分析</h2><p>负载分析是预计算推荐系统中的核心环节，它通过对采集的数据进行深入分析，挖掘用户使用数据库的规律性，为预计算推荐算法提供关键支持，如图3所示。</p><p> <img src="/../../images/image-20240804132306617.png" alt="image-20240804132306617"></p><p>负载分析主要包含两大类，对匹配成功的历史负载  和已有预计算元信息的分析和对匹配失败的历史负载  的分析：（1）对匹配成功的历史负载和已有预计算元信息的分析：对于成功匹配的负载，分析的重点在于评估预计算的使用效果，包括其对查询性能的提升程度和资源消耗情况。通过这种分析，可以识别出哪些预计算是高效的，哪些可能需要进一步的调整或优化。此外，对成功匹配的负载进行分析，还可以帮助用户更好地理解预计算的实际效益，从而做出更加合理的使用决策，这些分析的结果用于支持未来的预计算监控设计。（2）对匹配失败的历史负载的分析：对于匹配失败的预计算的历史负载，负载分析则更加注重于识别和理解查询模式，包括涉及的数据库、表、列、聚合函数、时间窗口和查询频次等关键信息，这些信息被转化为相应的数据结构，为预计算推荐算法提供了丰富的输入。预计算推荐算法可以推荐新的预计算来覆盖这些未被匹配的查询，实现查询效率的提升。</p><p>总而言之，负载分析是预计算推荐系统中不可或缺的一环，通过对采集数据的全面分析，负载分析不仅为预计算推荐算法提供了坚实的数据基础，还为用户提供了宝贵的洞察，帮助他们更好地理解和利用预计算，从而实现数据库查询性能的持续优化和提升。</p><h2 id="4-3预计算推荐"><a href="#4-3预计算推荐" class="headerlink" title="4.3预计算推荐"></a>4.3预计算推荐</h2><p>在本节中，我们首先实现了一种基于规则的预计算推荐算法，可以为用户推荐出相应的预计算以提升数据库的运行效率。接着，为了克服基于规则的预计算推荐算法在存储空间受限的场景下不适用的缺点，我们又提出了基于收益的预计算推荐算法，实现更好的推荐效果。</p><h3 id="4-3-1基于规则的预计算推荐算法"><a href="#4-3-1基于规则的预计算推荐算法" class="headerlink" title="4.3.1基于规则的预计算推荐算法"></a>4.3.1基于规则的预计算推荐算法</h3><p>基于规则的推荐算法采用贪心的思想，即一个预计算表尽可能支持匹配更多的查询，预计算与用户查询的关系为1:n的关系，即一个预计算可以服务多个不同的查询，所以推荐的预计算结果的聚合函数集合应该尽可能包含更多查询的聚合函数。推荐结果中的时间间隔尽可能采用匹配此预计算的历史负载中更小的时间间隔。具体算法如下：</p><p>假设待推荐预计算的目标表为 T，我们对Q_r以时间间隔interval为分组的查询语句表示为集合Q&#x3D;{q_1,q_2…q_n}。设基于规则的推荐算法为F，推荐结果为PC，那么该推荐任务可以形式化表述为PC&#x3D;F(T,Q)，具体的：提取所有查询<em>Q</em>中的interval，表示为I&#x3D;{i_1,i_2…i_n}，提取所有查询<em>Q</em>中的聚合函数，表示为G&#x3D;{g1,g2…gn} 。推荐算法F表示为：首先从历史查询中找出最小的interval，作为候选interval，即I_c&#x3D;min(I)。然后查找I中所有I_c的整倍数的interval，表示该PC_c可以同时服务于这些interval的查询，记为候选查询 Q_c。从聚合函数中提取候选查询Q_c包含的聚合函数G_c，通过DDL构建模块构造预计算创建语句:   并加入PC中。然后继续从Q中剔除已经推荐过预计算的查询Q_c，为剩余的查询重新贪心规则继续推荐预计算，直到Q为空。最终为用户推荐出的预计算集合为PC，用户可以根据需要选择实现。</p><p><img src="/../../images/image-20240808142459313.png" alt="image-20240808142459313"></p><h3 id="4-3-2基于收益的预计算推荐算法"><a href="#4-3-2基于收益的预计算推荐算法" class="headerlink" title="4.3.2基于收益的预计算推荐算法"></a>4.3.2基于收益的预计算推荐算法</h3><p>由于基于规则的预计算推荐算法采用贪心的思想，推荐的预计算结果不考虑成本，在存储空间受限的场景下就不再适用。因此我们提出了一种基于收益的预计算推荐算法，采用深度学习的方法对预计算的收益进行估计，并建模为整数规划问题，可以在存储空间受限的场景下推荐收益最高的预计算。我们的算法包括以下步骤：预计算候选的生成、预计算估计、预计算选择，下面我将详细说明。</p><p><strong>A.预计算候选的生成</strong></p><p>假设待推荐预计算的目标表为T，在预计算候选生成阶段，我们对工作负载按照时间间隔进行分组为Q&#x3D;{q_1,q_2…q_n}，提取所有时间间隔interval表示为 I&#x3D;{i_1,i_2…i_n}；提取聚合函数表示为G&#x3D;{g1,g2…gn}，针对每组 g_i 统计聚合函数的出现频率，并根据3sigma原则淘汰掉出现频率过低的聚合函数，剩余的聚合函数作为每组的聚合函数代表G’ ，最终会为每个分组构造一条预计算候选P&#x3D;DDL{T,I,G}。</p><p><strong>B.预计算估计</strong></p><p>预计算估计包含两个部分，分别是对成本的估计和对收益的估计。</p><p>（1）成本估计</p><ul><li>成本估计公式如下：</li></ul><p><img src="/../../images/image-20240716102113336.png" alt="image-20240816102113336"></p><p><img src="/../../images/image-20240804132522509.png" alt="image-20240804132522509"></p><p>（2）收益估计</p><p>收益的估计采用深度学习方法进行，输入为一条查询语句 q_i 和一条预计算语句 p_j ，输出为这条预计算为该查询带来的收益B_i,j  。</p><p>首先需要对查询和预计算的SQL语句进行特征提取，我们提取的特征包括聚合函数、查询中子表（设备）的个数、时间范围信息、时间间隔信息。以如下SQL为例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--query  </span><br><span class="hljs-keyword">SELECT</span> time_bucket(k_timestamp, <span class="hljs-string">&#x27;3600s&#x27;</span>) <span class="hljs-keyword">as</span> k_timestamp, <span class="hljs-built_in">max</span>(usage_user),   <br><span class="hljs-built_in">max</span>(usage_system)  <br><span class="hljs-keyword">FROM</span> cpu  <br><span class="hljs-keyword">WHERE</span> k_timestamp <span class="hljs-operator">&gt;</span> <span class="hljs-number">2017</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-keyword">AND</span> k_timestamp <span class="hljs-operator">&lt;</span> <span class="hljs-number">2017</span><span class="hljs-number">-01</span><span class="hljs-number">-02</span> <span class="hljs-number">01</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>  <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> time_bucket(k_timestamp, <span class="hljs-string">&#x27;3600s&#x27;</span>);  <br><span class="hljs-comment">--precomputing  </span><br><span class="hljs-keyword">SELECT</span> time_bucket(k_timestamp, <span class="hljs-string">&#x27;60s&#x27;</span>) <span class="hljs-keyword">as</span> k_timestamp,<span class="hljs-built_in">max</span>(usage_user), <span class="hljs-built_in">max</span>(usage_system),<span class="hljs-built_in">sum</span>(usage_iowait)<br><span class="hljs-keyword">FROM</span> cpu  <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> time_bucket(k_timestamp, <span class="hljs-string">&#x27;60s&#x27;</span>); <br></code></pre></td></tr></table></figure><p>进行特征提取后：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--query</span><br>聚合函数:[[<span class="hljs-string">&#x27;max&#x27;</span>, <span class="hljs-string">&#x27;usage_user&#x27;</span>],[<span class="hljs-string">&#x27;max&#x27;</span>,<span class="hljs-string">&#x27;usage_system&#x27;</span>]]<br>子表（设备）的个数:[<span class="hljs-number">2</span>]<br>时间间隔:[<span class="hljs-number">3600</span>]<br>时间范围:[<span class="hljs-number">86400</span>]<br><span class="hljs-comment">--precomputing </span><br>聚合函数:[[<span class="hljs-string">&#x27;max&#x27;</span>, <span class="hljs-string">&#x27;usage_user&#x27;</span>], [<span class="hljs-string">&#x27;max&#x27;</span>,<span class="hljs-string">&#x27;usage_system&#x27;</span>], [<span class="hljs-string">&#x27;sum&#x27;</span>,<span class="hljs-string">&#x27;usage_iowait&#x27;</span>],  <br>[<span class="hljs-string">&#x27;sum&#x27;</span>,<span class="hljs-string">&#x27;usage_irq&#x27;</span>]] <br>时间间隔:[<span class="hljs-number">60</span>]<br></code></pre></td></tr></table></figure><p>然后，我们需要对查询和预计算的聚合函数进行排序，防止因聚合函数输入次序不同带来的对输出结果的影响。接下来我们对特征进行编码，字符特征采用One-Hot编码，数值特征进行归一化。最后将编码后的向量进行Concat送入多层神经网络中，输出为收益的估计，模型整体框架如下图所示，</p><p>收益估计模型如下：</p><p><img src="/../../images/image-20240804132402817.png" alt="image-20240804132402817"></p><p><strong>C.预计算选择</strong></p><p>预计算选择问题是指从预计算候选中选择最终的预计算集合，以最大化查询效率。我们可以将问题建模为整数线性规划问题，即在存储空间受限的前提下，选择能够最大化收益的预计算集合，形式上，我们将该问题定义如下：</p><p>建模为整数线性规划问题：</p><p><img src="/../../images/image-20240804132537557.png" alt="image-20240804132537557"></p><p>算法如下：</p><p><img src="/../../images/image-20240808142606361.png" alt="image-20240808142606361"></p><h1 id="5、预计算推荐算法实验与结果分析"><a href="#5、预计算推荐算法实验与结果分析" class="headerlink" title="5、预计算推荐算法实验与结果分析"></a>5、预计算推荐算法实验与结果分析</h1><h2 id="5-1实验设置"><a href="#5-1实验设置" class="headerlink" title="5.1实验设置"></a>5.1实验设置</h2><h3 id="5-1-1实验环境"><a href="#5-1-1实验环境" class="headerlink" title="5.1.1实验环境"></a>5.1.1实验环境</h3><p>本文的实验由Python语言进行编写，操作系统以及一些用到的软件的版本分别如下：</p><ul><li><p>操作系统：Windows 10</p></li><li><p>Python版本：Python 3.7.5</p></li><li><p>IDE: Pycharm 2020.2</p></li><li><p>数据库：KaiwuDB 1.2</p></li></ul><p>KaiwuDB是一款由浪潮公司开发的分布式多模数据库，它特别适用于处理大规模的时序数据。当前，KaiwuDB 在工业物联网、数字能源、金融等均已成功完成落地实践[11]，它特别针对时序数据进行了优化，使其在时序数据库领域中具有竞争力，特别是在需要处理大规模时序数据和实时分析的业务场景中。</p><p>实验中用的机器的主要配置为：CPU Intel® Core™ i7-9750H，内存 16GB 2666 MHz，硬盘1TB。</p><h3 id="5-1-2数据准备"><a href="#5-1-2数据准备" class="headerlink" title="5.1.2数据准备"></a>5.1.2数据准备</h3><p><strong>A.数据集</strong></p><p>使用TSBS测试工具生成数据集[10]。目前 TSBS 支持 IOT 及 Devops 两种场景：</p><p>我们设置日期在[2016-01-01 08:00:00, 2016-01-31 08:00:00]范围内，设备数量为100。</p><p><strong>B.查询</strong></p><p>使用TSBS测试工具生成查询工作负载，目前TSBS在CPU-ONLY场景下支持15种查询工作负载[10]。我们选择其中符合预计算推荐规则的查询语句进行生成。</p><p><strong>5.1.3 Baseline</strong></p><p><strong>A.收益模型对比算法：</strong></p><ul><li><p>线性回归模型(LR)：一种使用线性函数来建模收益的机器学习方法，并使用欧几里得距离计算估计收益与实际收益之间的损失。</p></li><li><p>梯度提升模型（GBDT）：一种基于XGBoost的梯度提升决策树回归方法。</p></li><li><p>深度神经网络（DNN）：一种具有多个隐藏层的人工神经网络。</p></li><li><p>指标：MAPE（Mean Absolute Percent Error）：对于预测收益值  和真实值  ，   。</p></li></ul><p><strong>B.预计算推荐对比算法：</strong></p><ul><li><p>TopkFreq：选择历史负载中出现频率最高的语句作为预计算进行推荐。</p></li><li><p>TopkOver：选择历史负载中代价最小的语句作为预计算进行推荐。</p></li><li><p>TopkBen：选择历史负载中收益最高的语句作为预计算进行推荐。</p></li><li><p>Rule-Based：基于规则的预计算推荐算法。</p></li><li><p>Benefit-Based：基于收益的预计算推荐算法。</p></li><li><p>指标：收益模型估计的收益。</p></li></ul><h2 id="5-2实验结果"><a href="#5-2实验结果" class="headerlink" title="5.2实验结果"></a>5.2实验结果</h2><p><strong>5.2.1基于规则的预计算推荐算法效果实验</strong></p><p>在本节中，我们生成了90条查询用于评估基于规则的预计算推荐算法的效果，执行流程：打开预计算推荐开关，执行—遍所有查询，执行预计算推荐命令，根据推荐创建预计算，再执行—遍所有查询，观察两次查询的时间。</p><p> <img src="/../../images/image-20240804132713893.png" alt="image-20240804132713893"></p><p>如图所示，红色是不使用预计算的查询时间，蓝色是使用预计算的查询时间。根据实验结果可以看到，使用预计算的查询时间明显减少，推荐结果有效。</p><p><strong>5.2.2收益模型估计实验</strong></p><p>我们比较LR、GBDT和DNN的MAPE</p><table><thead><tr><th>MAPE</th><th>Median</th><th>90th</th><th>95th</th><th>99th</th><th>Max</th><th>Mean</th></tr></thead><tbody><tr><td>LR</td><td>15.54</td><td>40.67</td><td>42.36</td><td>151</td><td>361</td><td>37.32</td></tr><tr><td>GBDT</td><td>0.726</td><td>2.80</td><td>5.33</td><td>31.7</td><td>101</td><td>1.96</td></tr><tr><td>DNN</td><td>0.575</td><td>2.61</td><td>4.93</td><td>27.0</td><td>137</td><td>1.78</td></tr></tbody></table><p><strong>5.2.3预计算推荐算法的对比实验</strong></p><p>在本节中，我们生成一批历史负载，将我们的预计算推荐算法与现有的预计算推荐算法进行比较，并基于收益模型评估它们的效果。</p><p> <img src="/../../images/image-20240804132746455.png" alt="image-20240804132746455"></p><p>如图所示，横轴为设置的成本上限  ，纵轴为预计算推荐结果的收益  。</p><p>Benefit-Base、Rule-Based相比于各种贪心算法（Top-Fre、Top-Ben、Top-Over）能够带来的收益上限是更高的，原因是各种贪心算法只是从工作负载的SQL考虑，而没有考虑SQL的合并。各种贪心算法适用的场景也不同，比如在当前工作负载中，Top-Fre表现不好的原因是当前工作负载中的语句重复的很少。</p><p>Benefit-Base和Rule-Based能够带来的收益上限近似，但Benefit-Base可以灵活的设置成本上限，并选择在当前成本上限的前提下最大收益的预计算集合，Rule-Based并没有做到这点。</p><h1 id="6、结论"><a href="#6、结论" class="headerlink" title="6、结论"></a>6、结论</h1><p>本文设计了一种面向时序数据库的预计算推荐系统，包括数据采集、负载分析和预计算推荐三个部分，并设计了两种预计算推荐算法，包括基于规则的预计算推荐算法和基于收益的预计算推荐算法，自动地为用户推荐出相应的预计算集合以最大化数据库的查询效率。通过实验验证，我们的算法能够显著提高查询性能和效率。</p><p>总的来说，我们的研究为时序数据库领域中预计算自动化推荐提供了一个有效的解决方案，这对于处理大规模时序数据的应用具有重要意义。未来的工作可以进一步优化算法性能，并将其应用于更广泛的应用场景中，以满足不断增长的时序数据处理需求。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] Huang Xiangdong, Zheng Liangfan, Qiu Mingming, et al. Time series data aggregation index[J]. Journal of Tsinghua University: Science and Technology, 2016, 56(3): 229−236, 245 (in Chinese) （黄向东，郑亮帆，邱明明，等. 支持时序数据聚合函数的索引[J].清华大学学报：自然科学版，2016，56（3）：229−236，245）</p><p>[2] Han Y, Li G, Yuan H, et al. AutoView: An Autonomous Materialized View Management System with Encoder-Reducer[J]. IEEE Transactions on Knowledge and Data Engineering, 2022.</p><p>[3] Chirkova R, Yang J. Materialized views[J]. Foundations and Trends® in Databases, 2012, 4(4): 295-405.</p><p>[4] <a href="http://opentsdb.net/docs/build/html/user_guide/rollups.html">Rollup And Pre-Aggregates — OpenTSDB 2.4 documentation</a></p><p>[5] <a href="https://docs.influxdata.com/enterprise_influxdb/v1/">InfluxDB Enterprise Documentation (influxdata.com)</a></p><p>[6] <a href="https://www.timescale.com/">PostgreSQL ++ for time series and events | Timescale</a></p><p>[7] <a href="https://docs.taosdata.com/">TDengine 文档 | TDengine 文档 | 涛思数据 (taosdata.com)</a></p><p>[8] <a href="http://www.edgestone-it.com/NewsView.Asp?id=89">最新动态-刃之砺信息科技 (edgestone-it.com)</a></p><p>[9] <a href="https://kaiwudb.com/jishu/318.html">深入解析时序引擎的预计算功能-KaiwuDB</a></p><p>[10] <a href="https://github.com/timescale/tsbs">timescale&#x2F;tsbs: Time Series Benchmark Suite, a tool for comparing and evaluating databases for time series data (github.com)</a></p><p>[11] <a href="https://www.inspur.com/lcjtww/lcsjk/index.html">分布式多模数据库-浪潮 KaiwuDB (inspur.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>压缩算法的调研</title>
    <link href="/2024/06/25/%E7%A7%91%E7%A0%94/%E6%9C%89%E6%8D%9F%E5%8E%8B%E7%BC%A9+%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95/"/>
    <url>/2024/06/25/%E7%A7%91%E7%A0%94/%E6%9C%89%E6%8D%9F%E5%8E%8B%E7%BC%A9+%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>因毕业论文第二个研究点是压缩算法，所以最近展开一些调研：</p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>目前监控业务中绝大多数数据仍旧是浮点，且更让人关心的其实是大盘的趋势而不是精确的秒级数据，虽然Continuous Queries，预降采样可以以极低的成本满足部分查询的需求，但是源数据本身的存储也是必不可少的；分层存储已经可以使得冷数据可以降低到COS这样的低成本介质中，但是存储带宽也是一个不可忽略的因素，所以对于时序数据来说数据量本身是需要仔细斟酌的点。</p><h1 id="Part1"><a href="#Part1" class="headerlink" title="Part1"></a>Part1</h1><p>IPDPS16的论文《Fast Error-bounded Lossy HPC Data Compression with SZ》阐述了一种新的可限定误差边界的浮点有损压缩算法，和VLDB2015《A time-series compression technique and its application to the smart grid》中提出的基于贪心的分片多项式近似法基本类似，都是基于临近几个点去在目标错误限定范围内找到合适的曲线测定模型。</p><ul><li><p>对于在限定误差边界以内的点称为 Predictable Data（可预测点），进而用两个比特结合前面几个点的预测值来描述这个点，因为这个描述曲线模型的结构重复较高，可以继续使用LZ77压缩以达到更优秀的压缩比。</p></li><li><p>对于超过限定误差边界的点称为 Unpredictable Data（不可预测点），以IEEE 754标准浮点存储格式存储在另外一个分离的结构中，利用Binary Representation Analysis执行进一步压缩。1）把所有的值映射到一个贴近零且更小的范围之内，即让所有的值减去范围内中值（med&#x3D;(mini (ρ[i]) + maxi (ρ[i]))&#x2F;2)），因为越接近零，为了满足规定精度所需要的mantissa就更少。 2）基于1+Exp(vi)+RQ MBits在规定错误区间（含义参考第三段第三节）截断mantissa。3）In particular, we perform the XOR operation for the consecutive normalized values and compress each by using a leading zero count followed by the remaining significant bits.</p></li></ul><p>这一系列trick使得SZ在浮点有损压缩时错误范围限定在10^-4时压缩比可以达到5.4，解压不会超过制定错误范围，且解压较快O(N)。当然这是16年的数据，sz compressor是开源的，在我们内部集群上的压缩率还需要测试。缺点是因为经过多轮压缩，CPU消耗较大。</p><p>值得一提的是TDengine 2.4.0.10 及之后都支持其内部优化的SZ版本，公开数据来看在开启SZ压缩时写入性能降低20%左右。</p><h1 id="Part2"><a href="#Part2" class="headerlink" title="Part2"></a>Part2</h1><p>VLDB2015的论文《A time-series compression technique and its application to the smart grid》描述了一种分片回归的技术（Piecewise regression techniques），其将时间序列划分为固定长度或可变长度的区间，并使用回归函数描述它们。<br>这种算法采用三种回归函数，分别为：</p><ul><li><p>constant functions (polynomials of degree zero)：PMR-Midrange《Capturing sensor-generated time series with quality guarantees》</p></li><li><p>straight line functions (polynomials of first degree)：《 Approximations of one-dimensional dig ital signals under the l∞ norm》</p></li><li><p>polynomials of degree higher or equal than two：《Small-dimensional linear programming and convex hulls made easy》以贪心的思路从零阶多项式开始尝试压缩多个点，直到不满足指定精度约束的时候执行下一阶多项式尝试压缩多个点，当达到最⾼次数的多项式并且它不能再以请求的精度逼近时，然后选择实现最⾼压缩⽐的多项式。通过保存其开始和结束位置以及多项式的系数来压缩相应的段，然后从下⼀段开始重新开始。</p></li></ul><p>这乍上去和SZ算法非常像，因为SZ也是使用三种曲线测定函数，但是三种测定函数的输入参数是固定的，即1，2，3个参数，对于不满足可误差边界的点集，放入存储不可预测点的结构，在其中在规定误差边界内截断IEEE 754的mantissa，并对结果继续执行压缩。</p><p>这两篇论文其实光从理论很难分辨出谁优谁劣，因为两者都无法做到理论最优，所以论文中给出的压缩比作用并不是很大，主要能不能上生产还是看实现，这篇文章中虽然声称自己在HANA中实现了这种压缩算法，但却没有开源，我也没有搜到相关资料，而SZ已经是非常成熟的开源库了，所以仅仅看两者我肯定是选择SZ的。</p><h1 id="Part3"><a href="#Part3" class="headerlink" title="Part3"></a>Part3</h1><p>ICDE21的论文《Optimizing Error-Bounded Lossy Compression for Scientific Data by Dynamic Spline Interpolation》描述了一种用于SZ预测阶段基于Spline Interpolation的预测器，也是SZ3的最大功能亮点。其最主要解决的问题是在SZ2.X中对于高维度数据进行压缩时，如果指定了较高的误差界限，虽然压缩率提高，但是精度下降非常明显，导致图像失真；其次当误差边界降低时，压缩数据时系数开销会显著提升；这两点主要是因为线性回归下使用相邻的点来预测已经足够“精确”。</p><p>所以这篇文章解决的问题可以用一句话概述：The fundamental idea is to develop a dynamic multidimensional spline interpolation-based predictor to replace the linearregression-based predictor such that the coefficient overhead can be completely eliminated while still keeping a fairly high prediction accuracy.</p><p>spline法和线性回归有本质的不同；spline是根据已知的数据点重建新的数据点，试图建立一条穿过所有已知数据点的曲线；而后者是根据特定的数学公式寻求一条最接近已知数据点的曲线。 Spline interpolation是一种特殊的多项式Spline，试图通过找到尽可能低的多项式且找到穿过所有点。文章还提到在相对不光滑的数据集中Spline interpolation的准确性不如 Lorenzo predictor，所以采用均匀抽样3%的方法选择使用哪一个预测器。</p><p>文章在推导的时候举了一个一维Spline的例子，其中需要保留所有偶数的点，我不清楚这对于压缩率是否会有影响。这篇文章对于压缩数据时系数开销的优化我并不关心，我主要看到的是在指定错误区间内SZ3的错误精度更为优秀，但是一维压缩率是我担心的点。</p><h1 id="Part4"><a href="#Part4" class="headerlink" title="Part4"></a>Part4</h1><p>这篇文章我大概过了一遍，我觉得这篇文章对于没有了解过SZ代码的人来说比较不友好，在参数预测阶段根本不知道什么意思。文章思路大体上分为三个步骤：</p><ul><li><p>基于采样预测数据的压缩比率，但是具体方法在另外一篇文章中。文章提到 Accurately estimating the compression quality based on the sam-pled dataset is critical to selecting the best-fit parameter settings and predictors at runtime. 但是我不太明白这句话，为什么基于采样对于参数预测很重要？</p></li><li><p>离线的与在线的参数预测。离线就是用一堆参数组合，每一个参数算出一组优秀值，对于每个字段，首先确定最佳压缩比，然后收集压缩比大于95%×best_rato的参数设置。在为每个字段收集了相对较好的参数组合后，我们可以选择任何一个选定的参数组合，这可以实现至少95%的最高压缩率。然后统计每个个体参数的优秀候选值；在线预测是在优秀值中进行多次迭代选择最优的压缩率。</p></li><li><p>SECOND-ORDER DATA PREDICTION 没看</p></li></ul><p>总体来看比较学术，具体效果还是实际测试一下吧。</p><p><strong>参考：</strong></p><p>《Fast Error-bounded Lossy HPC Data Compression with SZ》<br>《A time-series compression technique and its application to the smart grid》<br>《Optimizing Error-Bounded Lossy Compression for Scientific Data by Dynamic Spline Interpolation》<br>《Significantly Improving Lossy Compression for HPC Datasetswith Second-Order Prediction and Parameter Optimization》</p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>word</title>
    <link href="/2024/06/24/%E7%A7%91%E7%A0%94/word/"/>
    <url>/2024/06/24/%E7%A7%91%E7%A0%94/word/</url>
    
    <content type="html"><![CDATA[<h1 id="word中插入mathtype公式行间距变化，要求固定值20磅"><a href="#word中插入mathtype公式行间距变化，要求固定值20磅" class="headerlink" title="word中插入mathtype公式行间距变化，要求固定值20磅"></a>word中插入mathtype公式行间距变化，要求固定值20磅</h1><p>1.设置间距单倍行距</p><p>不推荐，和固定值不一致</p><p>2.设置mathtype中的格式——间距</p><p><img src="/../../images/image-20240724114551172.png" alt="image-20240724114551172"></p><p>并取消文档网格设置</p><p><img src="/../../images/image-20240724114615646.png" alt="image-20240724114615646"></p>]]></content>
    
    
    <categories>
      
      <category>常用工具问题及解决办法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机克隆</title>
    <link href="/2024/06/15/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%8B%E9%9A%86/"/>
    <url>/2024/06/15/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%8B%E9%9A%86/</url>
    
    <content type="html"><![CDATA[<h1 id="克隆虚拟机后无法上网问题"><a href="#克隆虚拟机后无法上网问题" class="headerlink" title="克隆虚拟机后无法上网问题"></a>克隆虚拟机后无法上网问题</h1><p>解决方法：在克隆的虚拟机关闭状态，重新自动配置网络</p><p><img src="/./../images/image-20240715125801353.png" alt="image-20240715125801353"></p><p>然后点击移除该网络适配器，然后再添加一个新的网络适配器即可，生成网络适配器后，进行新的mac地址生成。</p><p><img src="/./../images/image-20240715125820730.png" alt="image-20240715125820730"></p><p>进入&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth33文件把uuid删除，然后重启即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">service network restart<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>常用工具问题及解决办法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>springboot常用工具</title>
    <link href="/2024/06/13/springboot%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94%E9%9D%9E%E8%87%AA%E5%88%9B/"/>
    <url>/2024/06/13/springboot%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94%E9%9D%9E%E8%87%AA%E5%88%9B/</url>
    
    <content type="html"><![CDATA[<p>环境：SpringBoot3.2.5</p><h3 id="1-获取进程ID"><a href="#1-获取进程ID" class="headerlink" title="1. 获取进程ID"></a>1. 获取进程ID</h3><p>如果你想在程序中获取当前SpringBoot运行的进程号，那么你可以使用ApplicationPid，该类非常方便的获取当前进程ID。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini">ApplicationPid <span class="hljs-attr">pid</span> = new ApplicationPid() <span class="hljs-comment">;</span><br>System.out.printf(&quot;进程ID: %s%n&quot;, pid.toString()) <span class="hljs-comment">;</span><br>1.2.<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">进程ID: 24416</span><br>1.<br></code></pre></td></tr></table></figure><p>当然你还可以通过如下方式，获取当前的进程号：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">#在META-INF/spring.factories中注册监听器</span><br><span class="hljs-attr">org.springframework.context.ApplicationListener</span>=\<br>org.springframework.boot.context.ApplicationPidFileWriter<br>1.2.3.<br></code></pre></td></tr></table></figure><p>该监听器会将当前的进程ID写入文件中，通过如下配置文件路径</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">pid:</span><br>    <span class="hljs-attr">file:</span> <span class="hljs-string">d:/app.pid</span><br><span class="hljs-number">1.2</span><span class="hljs-number">.3</span><span class="hljs-string">.</span><br></code></pre></td></tr></table></figure><p>还可以通过如下方式：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">String pid = ManagementFactory<span class="hljs-selector-class">.getRuntimeMXBean</span>()<span class="hljs-selector-class">.getName</span>()<span class="hljs-selector-class">.split</span>(&quot;@&quot;)<span class="hljs-selector-attr">[0]</span><br><span class="hljs-number">1</span>.<br></code></pre></td></tr></table></figure><p>这样也可以获取进程ID。</p><h3 id="2-应用运行主目录"><a href="#2-应用运行主目录" class="headerlink" title="2. 应用运行主目录"></a>2. 应用运行主目录</h3><p>ApplicationHome提供访问应用程序主目录的途径。尝试为Jar文件、解压缩文件和直接运行的应用程序选择一个合理的主目录。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">ApplicationHome home = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ApplicationHome</span>() ;<br>System.out.<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;dir: %s, source: %s%n&quot;</span>, home.<span class="hljs-built_in">getDir</span>(), home.<span class="hljs-built_in">getSource</span>()) ;<br><span class="hljs-number">1.2</span>.<br></code></pre></td></tr></table></figure><p>在IDE中运行输出结果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dir:</span> <span class="hljs-string">D:\java\workspace\test-app,</span> <span class="hljs-attr">source:</span> <span class="hljs-literal">null</span><br><span class="hljs-number">1</span><span class="hljs-string">.</span><br></code></pre></td></tr></table></figure><p>打成Jar后运行输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">dir</span>: D:\java\workspace\test-app\target, <br>  <span class="hljs-built_in">source</span>: D:\java\workspace\test-app\target\test-app-1.0.0.jar<br>1.2.<br></code></pre></td></tr></table></figure><p>通过jar运行后，source输出的是当前运行的jar包路径。</p><h3 id="3-获取Java版本"><a href="#3-获取Java版本" class="headerlink" title="3. 获取Java版本"></a>3. 获取Java版本</h3><p>要想知道当前SpringBoot运行时的java版本可以通过JavaVersion获取：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">System.out.<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Java Version: %s%n&quot;</span>, JavaVersion.<span class="hljs-built_in">getJavaVersion</span>()) ;<br><span class="hljs-number">1.</span><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">Java Version: 17<br>1.<br></code></pre></td></tr></table></figure><p>JavaVersion是个枚举类，定义了17~22枚举值，你还可以调用isEqualOrNewerThan和isOlderThan进行java版本的比较。</p><h3 id="4-应用临时目录"><a href="#4-应用临时目录" class="headerlink" title="4. 应用临时目录"></a>4. 应用临时目录</h3><p>ApplicationTemp类提供了访问应用程序特定的临时目录的功能。一般来说，不同的Spring Boot应用程序将得到不同的位置，但是，只需重新启动应用程序即可获得相同的位置。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini">ApplicationTemp <span class="hljs-attr">temp</span> = new ApplicationTemp() <span class="hljs-comment">;</span><br>System.out.printf(&quot;临时目录: %s%n&quot;, temp.getDir()) <span class="hljs-comment">;</span><br>1.2.<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">临时目录: C:\Users\MSI-NB\AppData\Local\Temp\561929B2C764E67BCDA2DF9DAE26EF121F7E5365</span><br>1.<br></code></pre></td></tr></table></figure><p>不论你在IDE下还是Jar方式运行，windows平台下临时目录都在这里的Temp下。</p><h3 id="5-系统属性-环境变量访问"><a href="#5-系统属性-环境变量访问" class="headerlink" title="5. 系统属性&#x2F;环境变量访问"></a>5. 系统属性&#x2F;环境变量访问</h3><p>当你需要访问系统属性时可以通过SystemProperties类非常方便的获取。如果你访问的属性不存在时（null），那么它会再从环境变量中获取(System#getenv)。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">System.<span class="hljs-keyword">out</span>.printf(<span class="hljs-string">&quot;java.home=%s%n&quot;</span>, SystemProperties.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;java.home&quot;</span>)) ;<br><span class="hljs-number">1.</span><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">java.home</span>=D:\software\jre<br>1.<br></code></pre></td></tr></table></figure><p>注：这里的get方法参数是可变长参数，你可以传递多个key，获取时遍历遇到不为null的直接返回。</p><h3 id="6-实例化对象"><a href="#6-实例化对象" class="headerlink" title="6. 实例化对象"></a>6. 实例化对象</h3><p>Instantiator通过注入可用参数来实例化对象的简单工厂。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DAO</span> &#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-title">implements</span> <span class="hljs-title">DAO</span> &#123;&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-title">implements</span> <span class="hljs-title">DAO</span> &#123;&#125;<br><span class="hljs-number">1.2</span><span class="hljs-number">.3</span>.<br></code></pre></td></tr></table></figure><p>注备上面几个类，接下通过Instantiator一次性实例化多个对象。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini">Instantiator&lt;DAO&gt; <span class="hljs-attr">instant</span> = new Instantiator&lt;&gt;(DAO.class, p -&gt; &#123;&#125;) <span class="hljs-comment">;</span><br>List&lt;DAO&gt; <span class="hljs-attr">ret</span> = instant.instantiate(List.of(<span class="hljs-string">&quot;com.pack.A&quot;</span>, <span class="hljs-string">&quot;com.pack.B&quot;</span>)) <span class="hljs-comment">;</span><br>System.out.printf(&quot;%s%n&quot;, ret) <span class="hljs-comment">;</span><br>1.2.3.<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">[com.pack.<span class="hljs-symbol">A@</span>3127cb44, com.pack.<span class="hljs-symbol">B@</span><span class="hljs-number">3234474</span>]<br><span class="hljs-number">1.</span><br></code></pre></td></tr></table></figure><p>非常方便的一次性帮助你实例化多个同类型的类。</p><h3 id="7-资源加载"><a href="#7-资源加载" class="headerlink" title="7. 资源加载"></a>7. 资源加载</h3><p>如果你想将后缀为.properties，.xml，.yaml资源文件加载，那么你可以使用PropertiesPropertySourceLoader与YamlPropertySourceLoader。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini">// 加载properties文件<br>PropertiesPropertySourceLoader <span class="hljs-attr">propertyLoader</span> = new PropertiesPropertySourceLoader() <span class="hljs-comment">;</span><br>List&lt;PropertySource&lt;?&gt;&gt; <span class="hljs-attr">list</span> = propertyLoader.load(<span class="hljs-string">&quot;pack&quot;</span>, new ClassPathResource(<span class="hljs-string">&quot;pack.properties&quot;</span>)) <span class="hljs-comment">;</span><br>System.out.printf(&quot;pack.*: %s%n&quot;, list.get(0).getSource()) <span class="hljs-comment">;</span><br>// 加载yaml文件<br>YamlPropertySourceLoader <span class="hljs-attr">yamlLoader</span> = new YamlPropertySourceLoader() <span class="hljs-comment">;</span><br>List&lt;PropertySource&lt;?&gt;&gt; <span class="hljs-attr">yamls</span> = yamlLoader.load(<span class="hljs-string">&quot;pack&quot;</span>, new ClassPathResource(<span class="hljs-string">&quot;pack.yml&quot;</span>)) <span class="hljs-comment">;</span><br>System.out.printf(&quot;pack.*: %s%n&quot;, yamls.get(0).getSource()) <span class="hljs-comment">;</span><br>1.2.3.4.5.6.7.8.<br></code></pre></td></tr></table></figure><p>通过上面2个Loader非常方便的将资源文件加载，加载后的List还可以注册到Environment中，在系统中直接访问。</p><h3 id="8-获取basePackages"><a href="#8-获取basePackages" class="headerlink" title="8. 获取basePackages"></a>8. 获取basePackages</h3><p>如果你需要在代码中获取当前应用启动类所在的基包basePackages，那么你可以通过如下方式：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">private</span> ConfigurableApplicationContext context ;<br>System.<span class="hljs-keyword">out</span>.printf(<span class="hljs-string">&quot;basepPckages: %s%n&quot;</span>, AutoConfigurationPackages.<span class="hljs-keyword">get</span>(context)) ;<br><span class="hljs-number">1.2</span>.<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">basepPckages: <span class="hljs-section">[com.pack]</span><br>1.<br></code></pre></td></tr></table></figure><p>内部注册的是一个BasePackages Bean，该类是静态私有的所以你没法直接访问，只能通过上面的方式。</p>]]></content>
    
    
    <categories>
      
      <category>常用工具问题及解决办法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记录git的一些问题及解决方法</title>
    <link href="/2024/06/11/git%E6%8A%A5%E9%94%99%E6%80%BB%E7%BB%93/"/>
    <url>/2024/06/11/git%E6%8A%A5%E9%94%99%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="克隆不通怎么办"><a href="#克隆不通怎么办" class="headerlink" title="克隆不通怎么办"></a>克隆不通怎么办</h1><p>1.一般从http换成git克隆就可以了。</p><p>2.开启git代理</p><p>先本机打开代理，</p><p><img src="/../images/image-20240722200054936.png" alt="image-20240722200054936"></p><p>然后虚拟机设置：</p><p>git config –global http.proxy “本机ip:7890”<br>git config –global https.proxy “本机ip:7890”</p><p>ps：取消代理可输入以下命令：</p><p>git config –global –unset http.proxy</p><p>git config –global –unset https.proxy</p><h1 id="解决Git报错：fatal-detected-dubious-ownership-in-repository-at"><a href="#解决Git报错：fatal-detected-dubious-ownership-in-repository-at" class="headerlink" title="解决Git报错：fatal: detected dubious ownership in repository at"></a>解决Git报错：fatal: detected dubious ownership in repository at</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>这是因为该项目的所有者与现在的Windows用户不一致，从而Git触发了对仓库不安全操作的保护机制</p><p>比如说： 该项目的所有者是 Administrator，而当前用户是pengmude, 那么就会导致上面的错误</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>输入以下命令即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git config --global --add safe.directory &quot;*&quot;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>常用工具问题及解决办法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记录linux的一些问题及解决方法</title>
    <link href="/2024/05/21/linux/"/>
    <url>/2024/05/21/linux/</url>
    
    <content type="html"><![CDATA[<h1 id="防止IP变化"><a href="#防止IP变化" class="headerlink" title="防止IP变化"></a>防止IP变化</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>​        每次在自己电脑打开VMware，进入Linux时，发现有时候ip会改变，导致传输文件或者远程连接出现问题，每次更改ip都要去更改其它文件相对麻烦。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>因为虚拟机的ip是动态分配的，是可能存在以下几种原因导致其发生变化：</p><p>主机连接的网络不一样，比如上次连接的是自己手机热点，这次换成网线连接；<br>主机关机，重新开机；<br>卸载VMware，重新导入虚拟机。</p><h2 id="解决（固定ip地址）"><a href="#解决（固定ip地址）" class="headerlink" title="解决（固定ip地址）"></a>解决（固定ip地址）</h2><p><strong>（一）准备工作</strong><br>1.查询虚拟机ip地址</p><p>ifconfig</p><p>2.查询网关ip</p><p>编辑一&gt;虚拟网络编译器一&gt;更改设置一&gt;上方选择NAT模式，下方选择NAT设置一&gt;网关IP</p><p><strong>（二）固定ip</strong><br>位置一&gt;计算机</p><p>进入以下位置<br>etc&#x2F;sysconfig&#x2F;network-scripts</p><p>右键进入终端，并打开虚拟机网卡配置文件 ifcfg-ens33</p><p>vim ifcfg-ens33</p><p>将dhcp更改为static，让IP分配规则静态化，不再改变<br>BOOTPROTO&#x3D;”static”</p><p> 在网卡配置文件的结尾处配置上虚拟机ip地址，网关IP，以及域名解析服务器。<br>IPADDR&#x3D;”自己的IP地址”<br>GATEWAY&#x3D;”自己的网关IP”</p><p>NAS1&#x3D;”同网关IP”</p><p>退出编辑并保存退出<br>Esc一&gt;:wq </p><p>重启网卡</p><p>systemctl restart network</p><p><strong>（三）查看网络是否联通</strong><br>1.本机查看</p><blockquote><p>ping 虚拟机的IP</p></blockquote><p>2.虚拟机查看</p><p>ping 本机IP</p><h1 id="未知的名称或服务"><a href="#未知的名称或服务" class="headerlink" title="未知的名称或服务"></a>未知的名称或服务</h1><p>有时候ping baidu.com会出现报错，未知的名称或服务</p><p>对接口添加dns信息；编辑&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ethxxxxxxx，x可能是其他数字，但一般是ifcfg-eth0的，具体的X根据你的网卡确定，在最下面添加：<br>DNS1&#x3D;8.8.8.8<br>DNS2&#x3D;114.114.114.114<br>保存后重启网络</p><p>systemctl restart NetworkManager.service</p><h1 id="虚拟ip的原理及使用"><a href="#虚拟ip的原理及使用" class="headerlink" title="虚拟ip的原理及使用"></a><strong>虚拟ip的原理及使用</strong></h1><p><strong>用于nginx实现高可用</strong></p><p><a href="https://www.cnblogs.com/jmcui/p/13055283.html">虚拟IP原理及使用 - JMCui - 博客园 (cnblogs.com)</a></p><p><strong>举个通俗的例子</strong></p><p>老王开了一个会所，地址是虹X路1.1.1.1，经营范围不太正规，经常被封，顾客以为店已经关门，其实里面热火朝天，所以老王急啊，于是开了一个后门，地址是2.2.2.1，于是顾客纷纷从后门进入，老王笑开了花…</p><p>过几天大门解封了，但后门由于弄堂改造，临时关闭了，熟门熟路的顾客从后门进不来了，有同学会问，大门都开着，顾客为何不从前门进店？因为这些顾客头脑比较简单，老王苦啊，痛定思痛，老王想出了一个好主意。</p><p>老王给顾客自己的电话号码4.4.4.1，叮嘱他们，以后来店消费之前，只要电话能打通（4.4.4.1路由可达），说明店还营业，前门进不来（1.1.1.1接口down）就走后门（2.2.2.1接口UP)；同理，如果后门进不来，可以走前门。</p><p>如果电话打不通（4.4.4.1路由消失），说明老王被关进去了，顾客就别来了，因为前门被封（1.1.1.1接口down)，后门也被封（2.2.2.1接口down），来了也是白来。</p><p><strong>谈点正经的</strong></p><p>其实电脑上的127.0.0.1也是一个VIP，只是用于本机进程间的通信标识符。</p><p>如果没有127.0.0.1，那么一旦物理接口down，TCP&#x2F;IP协议栈绑定在此接口上的IP就无法提供进程间的通信，所以非常不方便。</p><p>而有了127.0.0.1，不管物理接口状态如何，都可以进程间通信。</p><p>题主问题里的VIP，也是不依赖于任何物理接口，只要有一个物理接口处于工作状态（UP，可以和外部联系），就可以提供服务器的访问，当然需要通过路由发布将4.4.4.1发布出去，别的三层设备、主机需要知道如何到达4.4.4.1。</p>]]></content>
    
    
    <categories>
      
      <category>常用工具问题及解决办法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记录docker的一些问题及解决方法</title>
    <link href="/2024/05/05/docker/"/>
    <url>/2024/05/05/docker/</url>
    
    <content type="html"><![CDATA[<h2 id="设置开机自启动"><a href="#设置开机自启动" class="headerlink" title="设置开机自启动"></a>设置开机自启动</h2><p>例如启动一个MySQL容器需要开机自启则使用以下命令启动容器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">#  docker run -d <span class="hljs-attr">--name</span> mysql -<span class="hljs-selector-tag">p</span> <span class="hljs-number">3306</span>:<span class="hljs-number">3306</span> --restart=always<br>always - 无论退出状态是如何，都重启容器<br></code></pre></td></tr></table></figure><p>如果在启动的时候忘记加该参数两个方法实现自启动</p><ol><li>删除容器重新创建</li><li>更新容器<br>下面介绍如何更新<br>更新之前查看容器重启策略</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># docker inspect 521b7fb8f7da|grep -i <span class="hljs-string">&quot;RestartPolicy&quot;</span> -A 2</span><br>            <span class="hljs-string">&quot;RestartPolicy&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>                <span class="hljs-string">&quot;MaximumRetryCount&quot;</span>: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>解析</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># 通过容器id查看容器信息</span><br>docker inspect <span class="hljs-number">521</span>b7fb8f7da<br><span class="hljs-comment"># 管道符</span><br>|<br><span class="hljs-comment"># 通过关键字RestartPolicy匹配容器重启策略</span><br><span class="hljs-keyword">grep</span> -i <span class="hljs-string">&quot;RestartPolicy&quot;</span> <br><span class="hljs-comment"># 除了匹配的关键字还列出关键字下面两行</span><br>-A <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>可以看到重启策略关键字RestartPolicy对应的name为空<br>通过容器ID更新容器重启策略</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"># docker <span class="hljs-keyword">update</span> <span class="hljs-comment">--restart=always 521b7fb8f7da</span><br></code></pre></td></tr></table></figure><p>再次查看容器信息<br>已经设置为总是启动了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># docker inspect 521b7fb8f7da|grep -i <span class="hljs-string">&quot;RestartPolicy&quot;</span> -A 2</span><br>            <span class="hljs-string">&quot;RestartPolicy&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;always&quot;</span>,<br>                <span class="hljs-string">&quot;MaximumRetryCount&quot;</span>: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>如果想要重启不自动启动则使用以下命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"># docker <span class="hljs-keyword">update</span> <span class="hljs-comment">--restart=no 75038d7a530f</span><br></code></pre></td></tr></table></figure><h2 id="docker网络模式"><a href="#docker网络模式" class="headerlink" title="docker网络模式"></a>docker网络模式</h2><h2 id="docker拉取镜像报错"><a href="#docker拉取镜像报错" class="headerlink" title="docker拉取镜像报错"></a>docker拉取镜像报错</h2><p><strong>报错</strong></p><p> error pulling image configuration: Get <a href="https://production.cloudflare.docker.com/">https://production.cloudflare.docker.com</a></p><p><strong>解决</strong></p><p>能加多少镜像就加多少到&#x2F;etc&#x2F;docker&#x2F;daemon.json文件中，以下是阿里云镜像加速：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mkdir</span> -p /etc/docker<br>sudo <span class="hljs-built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="hljs-string">&#x27;EOF&#x27;</span><br>&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://9rfsxolh.mirror.aliyuncs.com&quot;</span>]<br>&#125;<br>EOF<br>sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><p>还有其他镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;http://hub-mirror.c.163.com&quot;</span>,<br><span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,<br><span class="hljs-string">&quot;https://registry.docker-cn.com&quot;</span>,<br><span class="hljs-string">&quot;http://hub-mirror.c.163.com&quot;</span>,<br><span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,<br><span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,<br><span class="hljs-string">&quot;https://hccwwfjl.mirror.aliyuncs.com&quot;</span><br></code></pre></td></tr></table></figure><p>最新镜像去github上看看</p><p><a href="https://github.com/sky22333/Docker-Hub">sky22333&#x2F;Docker-Hub: Docker Hub镜像加速or项目收集 (github.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>常用工具问题及解决办法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>云服务器端口不能使用的问题</title>
    <link href="/2024/04/01/%E7%9F%AD%E9%93%BE%E6%8E%A5/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%A3%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/04/01/%E7%9F%AD%E9%93%BE%E6%8E%A5/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%A3%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="云服务器端口不能使用"><a href="#云服务器端口不能使用" class="headerlink" title="云服务器端口不能使用"></a>云服务器端口不能使用</h2><p>本人在部署短链接过程中，所以需要开启某个端口，遇到以下两种端口情况，希望能帮助到你！</p><h3 id="1-首先需要去阿里云服务器中开放端口"><a href="#1-首先需要去阿里云服务器中开放端口" class="headerlink" title="1.首先需要去阿里云服务器中开放端口"></a>1.首先需要去阿里云服务器中开放端口</h3><p>安全组中：</p><p><img src="/../../images/image-20240731171028115.png" alt="image-20240731171028115"></p><h3 id="2-除了上述端口开启完，你还需要让这个端口在终端可以使用！"><a href="#2-除了上述端口开启完，你还需要让这个端口在终端可以使用！" class="headerlink" title="2.除了上述端口开启完，你还需要让这个端口在终端可以使用！"></a>2.除了上述端口开启完，你还需要让这个端口在终端可以使用！</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用这个命令查看，端口开放的情况，是否由于该端口已被占用</span><br>ss -tuln | grep :80<br></code></pre></td></tr></table></figure><p>若上述没有查找到指定端口被占用，并且端口也没有开放，则使用如下命令，因为阿里云服务器除了在安全组开放外，还要在服务器防火墙手动开启，<strong>除非你禁用服务器</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 如，我需要开启8888端口</span><br><span class="hljs-comment"># 即命令 iptables -I INPUT -m state --state NEW -m tcp -p tcp --dport 8888 -j ACCEPT</span><br>iptables -I INPUT -m state --state NEW -m tcp -p tcp --dport 端口 -j ACCEPT<br>iptables -I INPUT -m state --state NEW -m udp -p udp --dport 端口 -j ACCEPT<br> <br><span class="hljs-comment"># 删除防火墙规则，内容一样把 -I 换成 -D 就行了：</span><br>iptables -D INPUT -m state --state NEW -m tcp -p tcp --dport 端口 -j ACCEPT<br>iptables -D INPUT -m state --state NEW -m udp -p udp --dport 端口 -j ACCEPT<br></code></pre></td></tr></table></figure><h3 id="常用的操作端口的命令"><a href="#常用的操作端口的命令" class="headerlink" title="常用的操作端口的命令"></a><strong>常用的操作端口的命令</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">查看端口是否开启：<br>ss -tuln | grep :80<br><br>查看某端口上的进程：<br>lsof -i :5127<br></code></pre></td></tr></table></figure><p>测试端口是否开启的网站：</p><p><a href="https://tool.chinaz.com/port">端口扫描 - 站长工具 (chinaz.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>短链接</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>merge vs rebase</title>
    <link href="/2024/03/18/merge%20vs%20rebase%E2%80%94%E9%9D%9E%E8%87%AA%E5%88%9B/"/>
    <url>/2024/03/18/merge%20vs%20rebase%E2%80%94%E9%9D%9E%E8%87%AA%E5%88%9B/</url>
    
    <content type="html"><![CDATA[<p>两种常见的合并方式是 <code>merge</code> 和 <code>rebase</code>，它们各有优缺点，选择哪种方式需要根据具体情况来决定。</p><h2 id="Merge-和-Rebase-的区别"><a href="#Merge-和-Rebase-的区别" class="headerlink" title="Merge 和 Rebase 的区别"></a>Merge 和 Rebase 的区别</h2><h3 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h3><p><code>merge</code> 是将两个分支的历史记录合并在一起，产生一个新的提交（merge commit）。它的好处是保留了完整的历史记录，所有的提交顺序和分支点都清晰可见。</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换到目标分支</span><br>git checkout main<br><br><span class="hljs-comment"># 合并 feature 分支到 main</span><br>git merge feature<br></code></pre></td></tr></table></figure><p>合并后的历史记录可能如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">*</span>   d3adb33 (HEAD <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> main) <span class="hljs-keyword">Merge</span> branch <span class="hljs-string">&#x27;feature&#x27;</span> <span class="hljs-keyword">into</span> <span class="hljs-string">&#x27;main&#x27;</span><br><span class="hljs-operator">|</span>\<br><span class="hljs-operator">|</span> <span class="hljs-operator">*</span> <span class="hljs-number">1</span>a2b3c4 (feature) Feature <span class="hljs-keyword">commit</span> <span class="hljs-number">2</span><br><span class="hljs-operator">|</span> <span class="hljs-operator">*</span> <span class="hljs-number">5</span>d6e7f8 Feature <span class="hljs-keyword">commit</span> <span class="hljs-number">1</span><br><span class="hljs-operator">*</span> <span class="hljs-operator">|</span> <span class="hljs-number">8</span>a9b0c1 Main <span class="hljs-keyword">commit</span> <span class="hljs-number">2</span><br><span class="hljs-operator">*</span> <span class="hljs-operator">|</span> <span class="hljs-number">2</span>d3e4f5 Main <span class="hljs-keyword">commit</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><p><code>rebase</code> 是将一个分支的所有提交移到另一个分支的最前面，重写提交历史。这样可以使历史记录更简洁，线性化的提交历史看起来更干净。</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换到 feature 分支</span><br>git checkout feature<br><br><span class="hljs-comment"># 变基到 main 分支</span><br>git rebase main<br></code></pre></td></tr></table></figure><p>变基后的历史记录可能如下所示：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 1a2b3c4 (HEAD -&gt; feature) Feature commit 2<br><span class="hljs-bullet">*</span> 5d6e7f8 Feature commit 1<br><span class="hljs-bullet">*</span> 8a9b0c1 (main) Main commit 2<br><span class="hljs-bullet">*</span> 2d3e4f5 Main commit 1<br></code></pre></td></tr></table></figure><h2 id="何时使用-Merge"><a href="#何时使用-Merge" class="headerlink" title="何时使用 Merge"></a>何时使用 Merge</h2><h3 id="1-保留完整的历史记录"><a href="#1-保留完整的历史记录" class="headerlink" title="1. 保留完整的历史记录"></a>1. 保留完整的历史记录</h3><p>当你需要保留分支开发的完整历史记录时，使用 <code>merge</code> 是一个不错的选择。它可以清晰地显示出哪些工作是在分支上进行的，哪些是在主分支上进行的。</p><h3 id="2-解决复杂冲突"><a href="#2-解决复杂冲突" class="headerlink" title="2. 解决复杂冲突"></a>2. 解决复杂冲突</h3><p>当两个分支之间有复杂冲突时，<code>merge</code> 可以更容易地解决冲突，因为它会创建一个新的合并提交，让你在合并过程中进行冲突解决。</p><h2 id="何时使用-Rebase"><a href="#何时使用-Rebase" class="headerlink" title="何时使用 Rebase"></a>何时使用 Rebase</h2><h3 id="1-保持历史记录整洁"><a href="#1-保持历史记录整洁" class="headerlink" title="1. 保持历史记录整洁"></a>1. 保持历史记录整洁</h3><p>如果你希望提交历史看起来更干净、更线性，<code>rebase</code> 是更好的选择。它可以避免多余的合并提交，使历史记录更易读。</p><h3 id="2-在个人分支上工作"><a href="#2-在个人分支上工作" class="headerlink" title="2. 在个人分支上工作"></a>2. 在个人分支上工作</h3><p>在个人分支上工作时，可以频繁使用 <code>rebase</code> 来保持分支与主分支同步，而不引入多余的合并提交。</p><h2 id="具体示例：解决冲突"><a href="#具体示例：解决冲突" class="headerlink" title="具体示例：解决冲突"></a>具体示例：解决冲突</h2><p>假设我们有以下情况：</p><ul><li>主分支 <code>main</code> 上有两个提交</li><li>功能分支 <code>feature</code> 上有两个提交</li></ul><h3 id="使用-Merge-解决冲突"><a href="#使用-Merge-解决冲突" class="headerlink" title="使用 Merge 解决冲突"></a>使用 Merge 解决冲突</h3><ol><li>切换到主分支并合并功能分支：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">git checkout <span class="hljs-selector-tag">main</span><br>git merge feature<br></code></pre></td></tr></table></figure><ol><li>如果存在冲突，Git 会提示你手动解决冲突。打开冲突文件，进行手动修改，然后标记冲突已解决：</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta"># 编辑冲突文件并解决冲突</span><br>nano conflicted_file.java<br><br><span class="hljs-meta"># 标记冲突已解决</span><br>git <span class="hljs-keyword">add</span> conflicted_file.java<br></code></pre></td></tr></table></figure><ol><li>完成合并：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">git <span class="hljs-keyword">commit</span> <span class="hljs-operator">-</span>m &quot;Resolved conflicts and merged feature branch&quot;<br></code></pre></td></tr></table></figure><h3 id="使用-Rebase-解决冲突"><a href="#使用-Rebase-解决冲突" class="headerlink" title="使用 Rebase 解决冲突"></a>使用 Rebase 解决冲突</h3><ol><li>切换到功能分支并进行变基：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">git checkout feature<br>git rebase <span class="hljs-selector-tag">main</span><br></code></pre></td></tr></table></figure><ol><li>如果存在冲突，Git 会暂停变基并提示你手动解决冲突。打开冲突文件，进行手动修改，然后标记冲突已解决：</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta"># 编辑冲突文件并解决冲突</span><br>nano conflicted_file.java<br><br><span class="hljs-meta"># 标记冲突已解决</span><br>git <span class="hljs-keyword">add</span> conflicted_file.java<br></code></pre></td></tr></table></figure><ol><li>继续变基：</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">git rebase --<span class="hljs-keyword">continue</span><br></code></pre></td></tr></table></figure><h2 id="代码示例：实现简单的加法函数并合并冲突"><a href="#代码示例：实现简单的加法函数并合并冲突" class="headerlink" title="代码示例：实现简单的加法函数并合并冲突"></a>代码示例：实现简单的加法函数并合并冲突</h2><p>假设我们有以下代码文件 <code>math_utils.java</code>：</p><p>主分支上的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MathUtils</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>功能分支上的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MathUtils</span> &#123;<br>    <span class="hljs-comment">// 新增方法：加法并打印结果</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">addAndPrint</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> result = a + b;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Result: &quot;</span> + result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>合并过程中可能会产生冲突，因为两个分支都修改了同一个文件。使用 <code>merge</code> 或 <code>rebase</code> 解决冲突的方法类似，以下是使用 <code>merge</code> 解决冲突的步骤：</p><ol><li>切换到主分支并合并功能分支：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">git checkout <span class="hljs-selector-tag">main</span><br>git merge feature<br></code></pre></td></tr></table></figure><ol><li>解决冲突：</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MathUtils</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br><br>    <span class="hljs-comment">// 新增方法：加法并打印结果</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">addAndPrint</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> result = a + b;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Result: &quot;</span> + result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>标记冲突已解决并完成合并：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">git <span class="hljs-keyword">add</span> math_utils.java<br>git <span class="hljs-keyword">commit</span> <span class="hljs-operator">-</span>m &quot;Resolved conflicts and merged feature branch&quot;<br></code></pre></td></tr></table></figure><p>总之，选择 <code>merge</code> 还是 <code>rebase</code> 取决于具体的情境和需求。如果需要保留完整的历史记录并且更容易解决复杂冲突，<code>merge</code> 是更好的选择；如果希望历史记录更整洁且在线性开发过程中工作，<code>rebase</code> 则更合适。每种方法都有其优点和适用场景，熟练掌握并根据实际情况选择最合适的方法，是高效进行代码合并的关键。</p>]]></content>
    
    
    <categories>
      
      <category>常用工具问题及解决办法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>读写锁的应用</title>
    <link href="/2024/03/15/%E7%9F%AD%E9%93%BE%E6%8E%A5/%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2024/03/15/%E7%9F%AD%E9%93%BE%E6%8E%A5/%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>当我们修改了短链接分组时，需要获取写锁；当我们自增短链接监控记录全局访问 PV、UV、UIP 时，获取读锁。</p><p>为什么需要读写锁？因为如果 Gid 变更后，新增短链接监控获取的是旧的 Gid，自增监控记录就会统计错误问题。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>我们假设没有读写锁，流程如下：</p><ol><li>线程 A 将短链接分组从 <code>6688ja</code> 变更为 <code>8866ja</code>。注意，这个是准备要修改，还没有执行成功；</li><li>同时记录短链接监控线程 B 获取短链接分组为 <code>6688ja</code>，准备进行自增 PV、UV、UIP 数据；</li><li>此时线程 A 将短链接分组成功将 <code>6688ja</code> 变更为 <code>8866ja</code>；</li><li>线程 B 自增短链接 PV、UV、UIP 开始执行，但执行失败，因为已经没有了对应短链接的 <code>6688ja</code> 分组。</li></ol><p>为此，我们需要将短链接修改和监控数据自增隔离开来，以此来保障数据准确性。</p><p>自增执行 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span><span class="hljs-operator">!</span><span class="hljs-comment">-- 自增短链接访问次数 --&gt;</span><br><span class="hljs-operator">&lt;</span><span class="hljs-keyword">update</span> id<span class="hljs-operator">=</span>&quot;incrementStats&quot;<span class="hljs-operator">&gt;</span><br>    <span class="hljs-keyword">UPDATE</span> t_link<br>    <span class="hljs-keyword">SET</span> total_pv  <span class="hljs-operator">=</span> total_pv <span class="hljs-operator">+</span> #&#123;totalPv&#125;,<br>        total_uv  <span class="hljs-operator">=</span> total_uv <span class="hljs-operator">+</span> #&#123;totalUv&#125;,<br>        total_uip <span class="hljs-operator">=</span> total_uip <span class="hljs-operator">+</span> #&#123;totalUip&#125;<br>    <span class="hljs-keyword">WHERE</span> gid <span class="hljs-operator">=</span> #&#123;gid&#125;<br>      <span class="hljs-keyword">AND</span> full_short_url <span class="hljs-operator">=</span> #&#123;fullShortUrl&#125;<br><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span><span class="hljs-keyword">update</span><span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><h2 id="为什么用读写锁而不是用分布式锁？"><a href="#为什么用读写锁而不是用分布式锁？" class="headerlink" title="为什么用读写锁而不是用分布式锁？"></a>为什么用读写锁而不是用分布式锁？</h2><p>因为分布式锁是串行化，吞吐量较低。读写锁中有两个锁种类，读锁和读锁之间是可以共享的，写写和读写才是互斥的。</p><p>这里 <code>fullShortUrl</code> 全局唯一，那么 UV、PV 这些自增时为什么要带 gid 这个条件？如果不带 gid，那么是不是就可以省略读写锁了？</p><p>因为咱们短链接表是按照 gid 分表的，如果不加就会触发读扩散问题。</p>]]></content>
    
    
    <categories>
      
      <category>短链接</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>缓存和数据库一致性</title>
    <link href="/2024/03/02/%E7%9F%AD%E9%93%BE%E6%8E%A5/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <url>/2024/03/02/%E7%9F%AD%E9%93%BE%E6%8E%A5/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="方案介绍"><a href="#方案介绍" class="headerlink" title="方案介绍"></a>方案介绍</h1><p><img src="/../../images/image-20240731164719521.png" alt="image-20240731164719521"></p><p>我们对比上面讨论的 6 种方案：</p><p>1.先写 Redis，再写 MySQL</p><ul><li><p>这种方案，我肯定不会用，万一 DB 挂了，你把数据写到缓存，DB 无数据，这个是灾难性的；</p></li><li><p>我之前也见同学这么用过，如果写 DB 失败，对 Redis 进行逆操作，那如果逆操作失败呢，是不是还要搞个重试？</p></li></ul><p>2.先写 MySQL，再写 Redis</p><ul><li><p>对于并发量、一致性要求不高的项目，很多就是这么用的，我之前也经常这么搞，但是不建议这么做；</p></li><li><p>当 Redis 瞬间不可用的情况，需要报警出来，然后线下处理。</p></li></ul><p>3.先删除 Redis，再写 MySQL</p><p>这种方式，我还真没用过，直接忽略吧。</p><p>4.先删除 Redis，再写 MySQL，再删除 Redis</p><p>这种方式虽然可行，但是感觉好复杂，还要搞个消息队列去异步删除 Redis。</p><p>5.先写 MySQL，再删除 Redis</p><ul><li>比较推荐这种方式，删除 Redis 如果失败，可以再多重试几次，否则报警出来；</li><li>这个方案，是实时性中最好的方案，在一些高并发场景中，推荐这种。</li></ul><p>6.先写 MySQL，通过 Binlog，异步更新 Redis</p><ul><li>对于异地容灾、数据汇总等，建议会用这种方式，比如 binlog + kafka，数据的一致性也可以达到秒级；</li><li>纯粹的高并发场景，不建议用这种方案，比如抢购、秒杀等。</li></ul><h1 id="个人结论"><a href="#个人结论" class="headerlink" title="个人结论"></a><strong>个人结论</strong></h1><p>1.实时一致性方案：采用“先写 MySQL，再删除 Redis”的策略，这种情况虽然也会存在两者不一致，但是需要满足的条件有点苛刻，所以是满足实时性条件下，能尽量满足一致性的最优解。</p><p>2.最终一致性方案：采用“先写 MySQL，通过 Binlog，异步更新 Redis”，可以通过 Binlog，结合消息队列异步更新 Redis，是最终一致性的最优解。</p>]]></content>
    
    
    <categories>
      
      <category>短链接</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分片键的考量</title>
    <link href="/2024/02/20/%E7%9F%AD%E9%93%BE%E6%8E%A5/%E5%88%86%E7%89%87%E9%94%AE/"/>
    <url>/2024/02/20/%E7%9F%AD%E9%93%BE%E6%8E%A5/%E5%88%86%E7%89%87%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是分片键"><a href="#什么是分片键" class="headerlink" title="什么是分片键"></a>什么是分片键</h2><p>用于将数据库（表）水平拆分的数据库字段。 例：将订单表中的订单主键的尾数取模分片。 </p><p>简单来说，我们将短链接表拆分了 16 张分表，那用户新增短链接，怎么知道短链接记录应该放到哪张表里？这就需要用到分片键了，通过分片键进行一定规则（短链接表 t_link 使用的 HASH_MOD 方式）的运算，最终得到一个下标，这也就是我们要插入的分表位置。</p><p>得到一个下标指的是从 0-15 获取个值，然后和 <code>t_link_</code> 一拼接，就是我们 MySQL 数据库中的真实数据库表名称。</p><h2 id="选择分片键的角度"><a href="#选择分片键的角度" class="headerlink" title="选择分片键的角度"></a>选择分片键的角度</h2><p>有共性、少更改</p><h2 id="真实业务场景"><a href="#真实业务场景" class="headerlink" title="真实业务场景"></a>真实业务场景</h2><p>分表后，我们查询数据库 SQL 语句时，必须要带上分片键，否则会走全部分片表路由，性能较差。</p><p>为什么不用 <code>full_short_url</code> 分片，这样还可以少个路由表。不过，从我们真实业务场景种，这个是行不通的。</p><p>根据我们的功能原型得知，短链接是根据分组访问的，那么查询条件中就必须要带一个 Gid。如果我们按照full_short_url字段进行分表，相当于这个分页查询接口如果没有分片键分组标识 Gid 字段的话，就会扫描全部分片表，出现读扩散问题。</p><p>那 <code>t_link_goto</code> 表是做什么的呢？</p><p>用户通过浏览器访问短链接时，仅有短链接值，没有 Gid 的，所以我们就要建立个路由表，也就是 t_link_goto 进行缓存短链接和 Gid 的关系。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_link_goto` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;ID&#x27;</span>,<br>  `gid` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;default&#x27;</span> COMMENT <span class="hljs-string">&#x27;分组标识&#x27;</span>,<br>  `full_short_url` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;完整短链接&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">1768890503757107203</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4;<br></code></pre></td></tr></table></figure><p>通过短链接 <code>full_short_url</code> 查询 <code>t_link_goto</code> 表，获取到对应的 Gid，进而再去查询 <code>t_link</code> 表，这样就不会出现读扩散问题。</p><h2 id="分片框架选择"><a href="#分片框架选择" class="headerlink" title="分片框架选择"></a>分片框架选择</h2><p>如果项目对功能需求较高，希望在一个较为活跃的社区中获取支持，且对数据库的支持要求较高，那么 ShardingSphere 可能是一个更好的选择。如果项目相对简单，对生态和社区支持要求不高，那么 Mycat 也是一个稳定的选择。</p><p>咱们在项目中使用了 ShardingSphere-JDBC 的形式进行分表处理。</p>]]></content>
    
    
    <categories>
      
      <category>短链接</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>主要接口的流程梳理</title>
    <link href="/2024/02/11/%E5%A4%A7%E8%90%A5%E9%94%80%E9%A1%B9%E7%9B%AE/%E6%8A%BD%E5%A5%96%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/"/>
    <url>/2024/02/11/%E5%A4%A7%E8%90%A5%E9%94%80%E9%A1%B9%E7%9B%AE/%E6%8A%BD%E5%A5%96%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>看代码时很多细节不记得了，所以用图帮助回忆项目的主要部分。</p><h1 id="抽奖规则"><a href="#抽奖规则" class="headerlink" title="抽奖规则"></a>抽奖规则</h1><p>使用模板模式、责任链模式、组合模式定义抽奖规则，详情请见设计模式一节内容。</p><p><img src="/../../images/image-20240801161653031.png" alt="image-20240801161653031"></p><h1 id="抽奖流程-draw"><a href="#抽奖流程-draw" class="headerlink" title="抽奖流程(draw)"></a>抽奖流程(draw)</h1><h2 id="逻辑流程"><a href="#逻辑流程" class="headerlink" title="逻辑流程"></a>逻辑流程</h2><p><img src="/../../images/image-20240801154950350.png" alt="image-20240801154950350"></p><h2 id="与代码结合"><a href="#与代码结合" class="headerlink" title="与代码结合"></a>与代码结合</h2><p><img src="/../../images/image-20240810184901602.png" alt="image-20240810184901602"></p><h1 id="签到返利（calendarSignRebate）"><a href="#签到返利（calendarSignRebate）" class="headerlink" title="签到返利（calendarSignRebate）"></a>签到返利（calendarSignRebate）</h1><p>日常的返利会根据用户所完成的行为动作来触达，这包括；打卡、签到、连签、支付、开户、交易、信贷、拉新等各类的动作。</p><p>我们以签到为例子：</p><h2 id="逻辑流程-1"><a href="#逻辑流程-1" class="headerlink" title="逻辑流程"></a>逻辑流程</h2><p><img src="/../../images/image-20240801161007955.png" alt="image-20240801161007955"></p><h2 id="与代码结合-1"><a href="#与代码结合-1" class="headerlink" title="与代码结合"></a>与代码结合</h2><p><img src="/../../images/image-20240810184919925.png" alt="image-20240810184919925"></p><h1 id="积分兑换sku商品（creditPayExchangeSku）"><a href="#积分兑换sku商品（creditPayExchangeSku）" class="headerlink" title="积分兑换sku商品（creditPayExchangeSku）"></a>积分兑换sku商品（creditPayExchangeSku）</h1><h2 id="逻辑流程-2"><a href="#逻辑流程-2" class="headerlink" title="逻辑流程"></a>逻辑流程</h2><p><img src="/../../images/image-20240801161956950.png" alt="image-20240801161956950"></p><h2 id="与代码结合-2"><a href="#与代码结合-2" class="headerlink" title="与代码结合"></a>与代码结合</h2><p><img src="/../../images/image-20240810185606976.png" alt="image-20240810185606976"></p><h1 id="其他的API"><a href="#其他的API" class="headerlink" title="其他的API"></a>其他的API</h1><p><img src="/../../images/image-20240819161956288.png" alt="image-20240819161956288"></p>]]></content>
    
    
    <categories>
      
      <category>抽奖系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>短链接跳转</title>
    <link href="/2024/02/10/%E7%9F%AD%E9%93%BE%E6%8E%A5/%E7%9F%AD%E9%93%BE%E6%8E%A5%E8%B7%B3%E8%BD%AC/"/>
    <url>/2024/02/10/%E7%9F%AD%E9%93%BE%E6%8E%A5/%E7%9F%AD%E9%93%BE%E6%8E%A5%E8%B7%B3%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="短链接跳转业务"><a href="#短链接跳转业务" class="headerlink" title="短链接跳转业务"></a>短链接跳转业务</h1><p>大多短链接系统短链接跳转逻辑应该是这样的：用户通过浏览器输入短链接访问，通过短链接获取到原始链接并进行跳转。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿指在高并发的系统中，<strong>一个热点数据缓存过期或者在缓存中不存在</strong>，导致大量并发请求直接访问数据库，从而给数据库造成巨大压力，甚至可能引起宕机。</p><p>具体来说，当某个热点数据在缓存中过期时，<strong>如果此时有大量并发请求同时访问这个数据</strong>，由于缓存中不存在，所有请求都会直接访问数据库，导致数据库负载急剧增加。</p><p><img src="/../../images/image-20240731165620852.png" alt="image-20240731165620852"></p><p>一般来说，解决缓存击穿的主要方法分为三种：<strong>热点数据永不过期、热点数据预加载以及加分布式锁</strong>。</p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指在<strong>缓存中查询一个一定不存在的数据</strong>，由于缓存不命中，导致请求直接访问数据库，这将导致大量的请求打到数据库上，可能会导致数据库压力过大。</p><p>通常情况下，缓存是<strong>为了提高数据访问速度，避免频繁查询数据库</strong>。但如果攻击者故意请求缓存中不存在的数据，就会导致缓存不命中，请求直接访问数据库。</p><p><img src="/../../images/image-20240731165708539.png" alt="image-20240731165708539"></p><p>缓存穿透一般有几种解决方案：1. 空对象值缓存。2.使用锁。3.布隆过滤器</p><h1 id="我们的方案"><a href="#我们的方案" class="headerlink" title="我们的方案"></a>我们的方案</h1><p>如果说缓存不存在，那么就通过布隆过滤器进行初步筛选，然后<strong>判断是否存在缓存空值，如果存在直接返回失败</strong>。如果不存在缓存空值，使用锁机制避免多个相同请求同时访问数据库。最后，<strong>如果请求数据库为空，那么将为空的 Key 进行空对象值缓存</strong>。</p><p><img src="/../../images/image-20240731165820956.png" alt="image-20240731165820956"></p><h1 id="HTTP重定向"><a href="#HTTP重定向" class="headerlink" title="HTTP重定向"></a>HTTP重定向</h1><p>一般以 3xx 开头的代表重定向，表示网页发生了转移，需要重定向到对应的地址中去，两者区别是：</p><ul><li>301：表示永久性转移。会导致搜索引擎将旧的URL替换为新的 URL，并且浏览器会缓存新的 URL。对于后续的请求，浏览器会直接使用新的 URL 进行访问，而不会再发送请求到旧的 URL。</li><li>302：表示临时性转移。不会导致搜索引擎更新索引，它只是暂时重定向到新的 URL。浏览器会缓存新的 URL，但对于后续的请求，浏览器会继续发送请求到原始的 URL，而不是直接使用新的 URL。</li></ul><p>简单来说，通过 301 跳转，只会在访问一次后端请求，然后就被缓存到浏览器，后续就直接从浏览器拿，不需要再访问短链接服务了。</p><p>302 跳转，每次都需要去短链接服务获取最新的链接，再进行重定向，浏览器不缓存相关信息。</p><p>两者优缺点：</p><ul><li>301：优点对短链接后端服务压力比较小。缺点是后续短链接变更了原始链接，无法感知；以及无法记录详细的统计信息。</li><li>302：上边的缺点就是优点。缺点是每次访问后端服务器，可能压力会大一些，但是相对于获取到用户的行为，这种小缺点都是能接受的。</li></ul><p><strong>因为我们需要统计访问信息，所以选择302</strong></p><h1 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h1><p>缓存预热是指在应用程序启动或系统负载低峰期，提前将应用程序需要访问缓存的数据加载到缓存中，以便在实际的请求到来时能够快速响应。</p><p>缓存预热的目的是避免在实际请求到来时由于缓存冷启动而导致的延迟或性能下降。缓存冷启动是指在缓存中没有预先加载数据的情况下，第一次请求到达时需要从后端系统或数据库获取数据，并将其存储到缓存中。这个过程可能需要花费较长的时间，延迟了实际请求的响应时间。</p><h2 id="如何进行缓存预热？"><a href="#如何进行缓存预热？" class="headerlink" title="如何进行缓存预热？"></a>如何进行缓存预热？</h2><p>缓存预热有很多种方式，比如定时任务从数据库中查询进行预热等。我们这里在创建完短链接后就将短链接记录新增到缓存中。</p><p><strong>设置缓存的过期时间，设置多少合适？</strong></p><p>因为咱们短链接创建时是可以设置过期时间的，所以对于设置了过期时间的短链接，我们在缓存中也设置对应的时间即可。</p><p>那对于永久有效的短链接难道就不设置过期时间么？大家知道，短链接一般来说具有时效性，很多时候只会在一定时间内使用，过了这个时间后，用的人就很少了。所以，即使短链接永久有效，我们也得设置过期时间。不然，大量不使用的短链接放在缓存中，存储压力会比较大。</p><p>如果短链接设置的永久有效，我们默认一个月的过期时间。如果一个月后还有人访问，再去数据库加载数据，再设置一个月的过期时间即可。</p>]]></content>
    
    
    <categories>
      
      <category>短链接</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>短链接生成</title>
    <link href="/2024/02/02/%E7%9F%AD%E9%93%BE%E6%8E%A5/%E7%9F%AD%E9%93%BE%E6%8E%A5%E7%94%9F%E6%88%90/"/>
    <url>/2024/02/02/%E7%9F%AD%E9%93%BE%E6%8E%A5/%E7%9F%AD%E9%93%BE%E6%8E%A5%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="使用的什么方式生成短链接？"><a href="#使用的什么方式生成短链接？" class="headerlink" title="使用的什么方式生成短链接？"></a>使用的什么方式生成短链接？</h1><p>通过 Hash 算法将原始连接转换成一个 Hash 码，使用了 Google 出品的 MurmurHash 算法。因为生成的 Hash 码是十进制的，整体较长不利于短链接传播。为此，我们将十进制转换为 62 进制，也就是咱们最终的短链接。</p><h2 id="1-MurmurHash-算法"><a href="#1-MurmurHash-算法" class="headerlink" title="1. MurmurHash 算法"></a>1. MurmurHash 算法</h2><p>对于选择哈希函数，有很多人可能会提到使用 MD5、SHA 等加密算法。其实我们并不关心反向解密的难度，更重要的是关注哈希的运算速度和冲突概率。</p><p>最终推荐使用由 Google 开发的 MurmurHash 算法。MurmurHash 是一种非加密型哈希函数，适用于一般的哈希检索操作。与其他流行的哈希函数相比，MurmurHash 在处理规律性较强的键时具有更好的随机分布特性。由于它是非加密型的，相比 MD5、SHA 等加密算法，MurmurHash 的性能要高得多（实际上是 MD5 等加密算法的十倍以上）。正是由于这些优点，尽管它于 2008 年问世，但目前已广泛应用于 Redis、MemCache、Cassandra、HBase、Lucene 等许多知名软件中。</p><p>我们使用 Hutool 里的工具类，不过他的底层也是使用的 Google 算法。</p><h2 id="2-进制转换"><a href="#2-进制转换" class="headerlink" title="2. 进制转换"></a>2. 进制转换</h2><p>Base62 编码是将数据转换为只包含数字和字母的一种方法。它使用了 62 个字符，分别是 0-9、a-z、A-Z，可以作为 URL 短链接、文件名等场景的字符串表示，相对于 16 进制或 64 进制等其他编码，Base62 具有更高的可读性和稳定性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span>[] CHARS = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<br>        <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>,<br>        <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-string">&#x27;J&#x27;</span>, <span class="hljs-string">&#x27;K&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-string">&#x27;N&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;P&#x27;</span>, <span class="hljs-string">&#x27;Q&#x27;</span>, <span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-string">&#x27;S&#x27;</span>, <span class="hljs-string">&#x27;T&#x27;</span>, <span class="hljs-string">&#x27;U&#x27;</span>, <span class="hljs-string">&#x27;V&#x27;</span>, <span class="hljs-string">&#x27;W&#x27;</span>, <span class="hljs-string">&#x27;X&#x27;</span>, <span class="hljs-string">&#x27;Y&#x27;</span>, <span class="hljs-string">&#x27;Z&#x27;</span>,<br>        <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;j&#x27;</span>, <span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;q&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span><br>&#125;;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIZE</span> <span class="hljs-operator">=</span> CHARS.length;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">convertDecToBase62</span><span class="hljs-params">(<span class="hljs-type">long</span> num)</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">while</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (num % SIZE);<br>        sb.append(CHARS[i]);<br>        num /= SIZE;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.reverse().toString();<br>&#125;<br></code></pre></td></tr></table></figure><p>假设我们使用的是 26 个字母的大小写，加上 10 个数字，那么对于短链接可以表示的最大组合数量为：</p><p>N &#x3D; 4，组合数为 62 ^ 4 &#x3D; 14_776_336，1477 万左右。</p><p>N &#x3D; 5，组合数为 62 ^ 5 &#x3D; 916_132_832，9.16 亿左右。</p><p>N &#x3D; 6，组合数为 62 ^ 6 &#x3D; 56_800_235_584，568 亿左右。</p><p><img src="/./../../images/image-20240713150151051.png"></p><h2 id="为什么会冲突？"><a href="#为什么会冲突？" class="headerlink" title="为什么会冲突？"></a>为什么会冲突？</h2><p>哈希函数将输入的数据映射为一个固定长度的哈希值，而不同的输入可能会映射为相同的哈希值，这被称为哈希冲突。</p><p>在短链接生成过程中，原始长链接经过哈希函数进行计算，生成一个哈希值。如果两个不同的原始长链接经过哈希计算后得到相同的哈希值，那么它们将生成相同的短链接。</p><p>这种情况通常是由于哈希函数的输出空间有限，而输入空间却是无限的。因此，无论哈希函数的设计有多好，仍然存在一定的概率会出现冲突。</p><h2 id="为什么使用原始链接和-UUID-生成短链接？"><a href="#为什么使用原始链接和-UUID-生成短链接？" class="headerlink" title="为什么使用原始链接和 UUID 生成短链接？"></a>为什么使用原始链接和 UUID 生成短链接？</h2><p>生成的短链接是需要保障在当前域名下唯一的，那这个唯一又如何体现呢？每次查询数据库中已有短链接数据来判断是否唯一么？性能有点低，我们使用了布隆过滤器来进行判断。</p><p>当我们发现冲突后，将原始长链接与一个随机生成的 UUID 字符串拼接，通过拼接后的内容继续查询布隆过滤器，直到不存在为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">originUrl</span> <span class="hljs-operator">=</span> requestParam.getOriginUrl();<br>originUrl += UUID.randomUUID().toString();<br><span class="hljs-type">String</span> <span class="hljs-variable">shorUri</span> <span class="hljs-operator">=</span> HashUtil.hashToBase62(originUrl);<br></code></pre></td></tr></table></figure><h2 id="如果一直冲突怎么办？"><a href="#如果一直冲突怎么办？" class="headerlink" title="如果一直冲突怎么办？"></a>如果一直冲突怎么办？</h2><p>一直冲突的概率是很小的，但是针对这种概率事件，我们就要考虑到极端情况。为此，我们在代码加了一个判断变量，如果超过指定次数，就抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> String <span class="hljs-title function_">generateSuffix</span><span class="hljs-params">(ShortLinkCreateReqDTO requestParam)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">customGenerateCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    String shorUri;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> (customGenerateCount &gt; <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceException</span>(<span class="hljs-string">&quot;短链接频繁生成，请稍后再试&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">originUrl</span> <span class="hljs-operator">=</span> requestParam.getOriginUrl();<br>        originUrl += UUID.randomUUID().toString();<br>        shorUri = HashUtil.hashToBase62(originUrl);<br>        <span class="hljs-keyword">if</span> (!shortUriCreateCachePenetrationBloomFilter.contains(createShortLinkDefaultDomain + <span class="hljs-string">&quot;/&quot;</span> + shorUri)) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        customGenerateCount++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> shorUri;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>短链接</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>用户注册</title>
    <link href="/2024/01/26/%E7%9F%AD%E9%93%BE%E6%8E%A5/%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C/"/>
    <url>/2024/01/26/%E7%9F%AD%E9%93%BE%E6%8E%A5/%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="检查用户名是否存在"><a href="#检查用户名是否存在" class="headerlink" title="检查用户名是否存在"></a>检查用户名是否存在</h1><p>使用布隆过滤器</p><p><img src="/../../images/image-20240731174724593.png" alt="image-20240731174724593"></p><h1 id="用户注册"><a href="#用户注册" class="headerlink" title="用户注册"></a>用户注册</h1><h3 id="如何防止用户名重复？"><a href="#如何防止用户名重复？" class="headerlink" title="如何防止用户名重复？"></a>如何防止用户名重复？</h3><p>通过布隆过滤器把所有用户名进行加载。这样该功能就能完全隔离数据库。</p><p>数据库层面添加唯一索引。</p><h3 id="如何防止恶意请求毫秒级触发大量请求去一个未注册的用户名？"><a href="#如何防止恶意请求毫秒级触发大量请求去一个未注册的用户名？" class="headerlink" title="如何防止恶意请求毫秒级触发大量请求去一个未注册的用户名？"></a>如何防止恶意请求毫秒级触发大量请求去一个未注册的用户名？</h3><p>因为用户名没注册，所以布隆过滤器不存在，代表着可以触发注册流程插入数据库。但是如果恶意请求短时间海量请求，这些请求都会落到数据库，造成数据库访问压力。这里通过分布式锁，锁定用户名进行串行执行，防止恶意请求利用未注册用户名将请求打到数据库。</p><p>流程执行图：</p><p><img src="/../../images/image-20240731170309519.png" alt="image-20240731170309519"></p><h3 id="如果恶意请求全部使用未注册用户名发起注册"><a href="#如果恶意请求全部使用未注册用户名发起注册" class="headerlink" title="如果恶意请求全部使用未注册用户名发起注册"></a>如果恶意请求全部使用未注册用户名发起注册</h3><p>系统无法进行完全风控，只有通过类似于限流的功能进行保障系统安全。</p><h1 id="敏感数据加密"><a href="#敏感数据加密" class="headerlink" title="敏感数据加密"></a>敏感数据加密</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 配置数据源，底层被 ShardingSphere 进行了代理</span><br><span class="hljs-attr">dataSources:</span><br>  <span class="hljs-attr">ds_0:</span><br>    <span class="hljs-attr">dataSourceClassName:</span> <span class="hljs-string">com.zaxxer.hikari.HikariDataSource</span><br>    <span class="hljs-attr">driverClassName:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">jdbcUrl:</span> <span class="hljs-string">jdbc:mysql://127.0.0.1:3306/link?useUnicode=true&amp;characterEncoding=UTF-8&amp;rewriteBatchedStatements=true&amp;allowMultiQueries=true&amp;serverTimezone=Asia/Shanghai</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br><br><span class="hljs-attr">rules:</span><br><span class="hljs-comment"># 数据加密存储规则</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-type">!ENCRYPT</span><br>    <span class="hljs-comment"># 需要加密的表集合</span><br>    <span class="hljs-attr">tables:</span><br>      <span class="hljs-comment"># 用户表</span><br>      <span class="hljs-attr">t_user:</span><br>        <span class="hljs-comment"># 用户表中哪些字段需要进行加密</span><br>        <span class="hljs-attr">columns:</span><br>          <span class="hljs-comment"># 手机号字段，逻辑字段，不一定是在数据库中真实存在</span><br>          <span class="hljs-attr">phone:</span><br>            <span class="hljs-comment"># 手机号字段存储的密文字段，这个是数据库中真实存在的字段</span><br>            <span class="hljs-attr">cipherColumn:</span> <span class="hljs-string">phone</span><br>            <span class="hljs-comment"># 身份证字段加密算法</span><br>            <span class="hljs-attr">encryptorName:</span> <span class="hljs-string">common_encryptor</span><br>          <span class="hljs-attr">mail:</span><br>            <span class="hljs-attr">cipherColumn:</span> <span class="hljs-string">mail</span><br>            <span class="hljs-attr">encryptorName:</span> <span class="hljs-string">common_encryptor</span><br>        <span class="hljs-comment"># 是否按照密文字段查询</span><br>        <span class="hljs-attr">queryWithCipherColumn:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment"># 加密算法</span><br>    <span class="hljs-attr">encryptors:</span><br>      <span class="hljs-comment"># 自定义加密算法名称</span><br>      <span class="hljs-attr">common_encryptor:</span><br>        <span class="hljs-comment"># 加密算法类型</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">AES</span><br>        <span class="hljs-attr">props:</span><br>          <span class="hljs-comment"># AES 加密密钥</span><br>          <span class="hljs-attr">aes-key-value:</span> <span class="hljs-string">d6oadClrrb9A3GWo</span><br><span class="hljs-attr">props:</span><br>  <span class="hljs-attr">sql-show:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>短链接</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>抽奖算法</title>
    <link href="/2024/01/17/%E5%A4%A7%E8%90%A5%E9%94%80%E9%A1%B9%E7%9B%AE/%E6%8A%BD%E5%A5%96%E7%AE%97%E6%B3%95/"/>
    <url>/2024/01/17/%E5%A4%A7%E8%90%A5%E9%94%80%E9%A1%B9%E7%9B%AE/%E6%8A%BD%E5%A5%96%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>抽奖算法有不少，我们考虑稍微简单的两种。</p><h1 id="我们的考量"><a href="#我们的考量" class="headerlink" title="我们的考量"></a>我们的考量</h1><h2 id="一、时间换空间"><a href="#一、时间换空间" class="headerlink" title="一、时间换空间"></a>一、时间换空间</h2><p>可以抽奖的时候生成一个随机值，之后和概率范围for循环比对。这样的场景适合那种需要，非常大的空间存放抽奖概率，不划算的时候，可以考虑这种。</p><p><img src="/../../images/image-20240729143548648.png" alt="image-20240729143548648"></p><h2 id="二、空间换时间"><a href="#二、空间换时间" class="headerlink" title="二、空间换时间"></a>二、空间换时间</h2><p>提前计算好抽奖概率分布，用本地内存 guava 或者 redis 存储，最后抽奖的时候通过生成的随机值，在空间内定位即可，复杂度为O(1)。</p><p><img src="/../../images/image-20240729143555897.png" alt="image-20240729143555897"></p><p>计算公式：</p><ol><li>找到范围内最小的概率值，比如 0.1、0.02、0.003，需要找到的值是 0.003</li><li>基于1找到的最小值，0.003 就可以计算出百分比、千分比的整数值。这里就是1000</li><li>那么「概率 * 1000」分别占比100个、20个、3个，总计是123个</li><li>后续的抽奖就用123作为随机数的范围值，生成的值100个都是0.1概率的奖品、20个是概率0.02的奖品、最后是3个是0.003的奖品。</li></ol><h2 id="三、我的选择"><a href="#三、我的选择" class="headerlink" title="三、我的选择"></a>三、我的选择</h2><p>因为空间换时间的复杂度只有O(1)，适合于高并发场景，所以选择空间换时间方案。</p>]]></content>
    
    
    <categories>
      
      <category>抽奖系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>抽奖过程中设计模式的运用</title>
    <link href="/2024/01/07/%E5%A4%A7%E8%90%A5%E9%94%80%E9%A1%B9%E7%9B%AE/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/01/07/%E5%A4%A7%E8%90%A5%E9%94%80%E9%A1%B9%E7%9B%AE/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h1><p>赵四把做饭的步骤交给了张三，具体实现由张三实现。</p><p><img src="/../../images/image-20240727133910827.png" alt="image-20240727133910827"></p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>父类是一个抽象类，如下图，template负责组合step1，step2……，也就是负责组合具体步骤，具体子类实现step1，step2……（行为由父类控制，实现由子类实现）</p><p><img src="/../../images/image-20240727134055986.png" alt="image-20240727134055986"></p><h2 id="抽奖项目中的运用"><a href="#抽奖项目中的运用" class="headerlink" title="抽奖项目中的运用"></a>抽奖项目中的运用</h2><p>责任链抽奖和规则树过滤交给子类去实现。</p><p><img src="/../../images/image-20240728112823077.png" alt="image-20240728112823077"></p><h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><h2 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h2><ul><li>抽象处理类：1.设置下一个处理者；2.抽象处理请求</li><li>实现类：继承抽象处理类并复写处理请求方法</li></ul><p><img src="/../../images/image-20240727135340082.png" alt="image-20240727135340082"></p><h2 id="与工厂模式结合"><a href="#与工厂模式结合" class="headerlink" title="与工厂模式结合"></a>与工厂模式结合</h2><p>使用工厂模式构建责任链</p><h2 id="抽奖项目"><a href="#抽奖项目" class="headerlink" title="抽奖项目"></a>抽奖项目</h2><p>使用责任链模式完成：黑名单——权重——默认抽奖的流程。</p><h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>又叫作整体-部分（Part-Whole）模式，它将对象组合成树状的层次结构，用来表示整体-部分的关系，使用户对单个对象和组合对象具有一致的访问性，属于结构型模式。</p><p><img src="/../../images/image-20240729141208623.png" alt="image-20240729141208623"></p><p>由上图可以看出，</p><ul><li><p>根节点和树枝节点本质上属于同一种数据类型，可以作为容器使用。</p></li><li><p>叶子节点与树枝节点在语义上不属于用一种类型。在组合模式中，会把树枝节点和叶子节点看作属于同一种数据类型（用统一接口定义），让它们具备一致行为。</p></li></ul><p>组合模式在树型结构中，模糊了简单元素（叶子节点）和复杂元素（树枝节点）的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p><h2 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a>类图</h2><p>component：公共抽象类，定义共同的行为；</p><p>left和composit相当于二叉树中的叶子节点和非叶子节点，类似于文件夹和文件。</p><p><img src="/../../images/image-20240727142256524.png" alt="image-20240727142256524"></p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>文件夹：文件夹可以有子文件夹和文件。遍历某个文件夹下所有文件时，就需要用到组合模式</p><h2 id="抽奖项目中"><a href="#抽奖项目中" class="headerlink" title="抽奖项目中"></a>抽奖项目中</h2><p><img src="/../../images/image-20240729141408239.png" alt="image-20240729141408239"></p><p>抽奖后的判断采用类似于组合模式的方式，构建规则树。</p>]]></content>
    
    
    <categories>
      
      <category>抽奖系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>桥接模式、nat模式和主机模式</title>
    <link href="/2024/01/01/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/01/01/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>虚拟机可以和外部系统通讯，但会浪费宿主的ip</p><p><img src="/../images/image-20240711200106245.png" alt="image-20240711200106245"></p><h2 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a>NAT模式</h2><p>虚拟机互通、可以和外部通讯，但用的不是同一个网段；外部不可以和虚拟器通讯</p><p><img src="/../images/image-20240711201909422.png" alt="image-20240711201909422"></p><h2 id="内部网络"><a href="#内部网络" class="headerlink" title="内部网络"></a>内部网络</h2><p>虚拟机之间可以互相通讯，但和外部无联系</p><p><img src="/../images/image-20240711195727113.png" alt="image-20240711195727113"></p><h2 id="仅主机模式"><a href="#仅主机模式" class="headerlink" title="仅主机模式"></a>仅主机模式</h2><p>独立系统，不和外部发生联系</p><p><img src="/../images/image-20240711202304552.png" alt="image-20240711202304552"></p><h2 id="docker中的网络"><a href="#docker中的网络" class="headerlink" title="docker中的网络"></a>docker中的网络</h2><p>默认情况下，所有容器都是以bridge方式连接到Docker的一个虚拟网桥上</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>表的设计</title>
    <link href="/2023/12/20/%E5%A4%A7%E8%90%A5%E9%94%80%E9%A1%B9%E7%9B%AE/%E8%A1%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/12/20/%E5%A4%A7%E8%90%A5%E9%94%80%E9%A1%B9%E7%9B%AE/%E8%A1%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>表的关系经常容易搞混，所以记录一下，方便回忆。</p><h1 id="系统表"><a href="#系统表" class="headerlink" title="系统表"></a>系统表</h1><p>策略表（strategy）：定义了不同的抽奖策略：不同策略抽奖的概率不同，抽奖的规则不同。</p><p>策略奖品表（strategy_award）：不同策略对应的奖品信息：包含奖品的概率、奖品的库存、抽到奖品的后置规则等。</p><p>策略规则表（strategy_rule）：不同策略有哪些前置规则：比如配置的黑名单、权重信息。</p><p>规则树表（rule_tree）、规则树节点表（rule_tree_node）、规则树节点连线表（rule_tree_node_line）：这三个表可以构成抽奖的后置规则树。</p><p>活动表（raffle_activity）：配置了用户参与一个活动的时候，需要进行的必要信息。比如：起始和终止时间、活动对应的策略。</p><p>活动sku表（raffle_activity_sku）：用于后续积分兑换的商品，也用于签到返利。包含：sku的库存、价格等信息</p><p><img src="/../../images/image-20240729151119053.png" alt="image-20240729151119053"></p><p>活动sku库存表（raffle_activity_count）：包含sku返利信息：比如能加多少次抽奖次数。</p><p>签到返利配置表（daily_behavior_rebate）：签到返利配置</p><h1 id="用户表"><a href="#用户表" class="headerlink" title="用户表"></a>用户表</h1><p>活动账户表（raffle_activity_account）：包含某个用户总共的抽奖次数、可用的抽奖次数</p><p>活动订单表（raffle_activity_order）：涉及用户与sku商品交易的订单表，包括：签到返利、积分兑换</p><p>用户抽奖订单表（user_raffle_order）：参与活动产生的订单</p><p>返利订单表（user_behavior_rebate_order）：签到返利产生的订单</p><p>积分账户表（user_credit_account）：积分账户</p><p>积分订单表（user_credit_order）：积分变化产生的订单，比如：签到返利、积分兑换sku</p><p>奖品记录表（user_award_record）：抽奖记录表</p><p>task表：任务补偿。如果MQ发送失败，使用定时任务补偿。</p><h1 id="总体结构如下"><a href="#总体结构如下" class="headerlink" title="总体结构如下"></a>总体结构如下</h1><p><img src="/../../images/FhHmf7peFTpnWqoBgWbhlZ_rXXGZ.png" alt="FhHmf7peFTpnWqoBgWbhlZ_rXXGZ"></p>]]></content>
    
    
    <categories>
      
      <category>抽奖系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>redis的一些配置问题</title>
    <link href="/2023/12/03/redis%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/12/03/redis%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="redis取消密码"><a href="#redis取消密码" class="headerlink" title="redis取消密码"></a>redis取消密码</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>docker exec -it 027e redis-cli</p><p>AUTH 现有密码</p><p>config set requirepass ‘’</p><p>使用SAVE命令保存更改</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>永久取消密码要去redis.config中设置。</p><p>官方的Redis镜像默认是没有配置文件的。</p><p><a href="https://blog.51cto.com/u_16213420/10677688">redis容器没有配置文件_mob64ca12edad02的技术博客_51CTO博客</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo问题</title>
    <link href="/2023/11/01/hexo/hexo/"/>
    <url>/2023/11/01/hexo/hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="配置hexo环境"><a href="#配置hexo环境" class="headerlink" title="配置hexo环境"></a>配置hexo环境</h1><p>详细过程参考如下地址：</p><p><a href="https://www.bilibili.com/video/BV1Yb411a7ty/?spm_id_from=333.880.my_history.page.click">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo_哔哩哔哩_bilibili</a></p><h1 id="每次修改后需要做的"><a href="#每次修改后需要做的" class="headerlink" title="每次修改后需要做的"></a>每次修改后需要做的</h1><p>完成任意配置后,输入以下指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></td></tr></table></figure><p>在本地localhost:4000 预览效果。然后运行以下命令推送到github</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo d<br></code></pre></td></tr></table></figure><h1 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h1><p>1.在source文件夹下创建images文件夹，以后所有的图片都放这边。</p><p>2.需要将typora中图片显示修改为相对位置才行。</p><h1 id="Front-matter的设置"><a href="#Front-matter的设置" class="headerlink" title="Front-matter的设置"></a>Front-matter的设置</h1><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Hello</span> <span class="hljs-string">World</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2013</span><span class="hljs-string">/7/13</span> <span class="hljs-number">20</span><span class="hljs-string">:46:25</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>常用参数见<a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter | Hexo</a></p><h1 id="主题修改（以fluid主题为例）"><a href="#主题修改（以fluid主题为例）" class="headerlink" title="主题修改（以fluid主题为例）"></a>主题修改（以fluid主题为例）</h1><p>1.使用npm安装主题</p><p>2.创建新的_config.fluid.yml配置文件</p><p>3.在_config.yml文件中修改theme配置</p><p>4.重新加载</p><p>参考地址：<a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid-dev&#x2F;hexo-theme-fluid: :ocean: 一款 Material Design 风格的 Hexo 主题 &#x2F; An elegant Material-Design theme for Hexo (github.com)</a></p><h1 id="图片无法显示问题"><a href="#图片无法显示问题" class="headerlink" title="图片无法显示问题"></a>图片无法显示问题</h1><h2 id="typora配置"><a href="#typora配置" class="headerlink" title="typora配置"></a>typora配置</h2><p><img src="/../../images/image-20240719140210761.png" alt="image-20240719140210761"></p><h2 id="路径配置"><a href="#路径配置" class="headerlink" title="路径配置"></a>路径配置</h2><p>使用上述配置即可，把所有的图片复制到blog\source\images路径下。</p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>conda</title>
    <link href="/2023/10/08/python/conda/"/>
    <url>/2023/10/08/python/conda/</url>
    
    <content type="html"><![CDATA[<h1 id="conda常用命令"><a href="#conda常用命令" class="headerlink" title="conda常用命令"></a>conda常用命令</h1><p><strong>创建环境</strong></p><p>conda create –name myenv python&#x3D;3.8</p><p><strong>激活环境</strong></p><p>conda activate myenv</p><p><strong>查看所有环境</strong></p><p>conda env list</p><p><strong>删除环境</strong></p><p>conda env remove –name myenv</p><p><strong>安装包</strong></p><p>conda install package_name</p><p>conda install package_name&#x3D;1.2.3</p><p><strong>卸载包</strong></p><p>conda remove package_name</p><p><strong>查看包</strong></p><p>conda list</p><h1 id="pycharm中配置conda环境"><a href="#pycharm中配置conda环境" class="headerlink" title="pycharm中配置conda环境"></a>pycharm中配置conda环境</h1><p><img src="/../../images/image-20240723110030054.png" alt="image-20240723110030054"></p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记录idea的一些问题及解决方法</title>
    <link href="/2023/09/30/idea%E6%8A%A5%E9%94%99/"/>
    <url>/2023/09/30/idea%E6%8A%A5%E9%94%99/</url>
    
    <content type="html"><![CDATA[<h1 id="java-程序包org-junit不存在"><a href="#java-程序包org-junit不存在" class="headerlink" title="java: 程序包org.junit不存在"></a>java: 程序包org.junit不存在</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>版本不匹配，换版本</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>进入File–&gt;settings–&gt; Build, Execution, Deployment–&gt;Build Tools–&gt;Maven–&gt;Runner界面<br>勾选“Delegate IDE build&#x2F;run actions to Maven”。如下图</p><p><img src="/../images/image-20240720122241227.png" alt="image-20240720122241227"></p>]]></content>
    
    
    <categories>
      
      <category>常用工具问题及解决办法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记录nginx的一些配置</title>
    <link href="/2023/09/30/nginx%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2023/09/30/nginx%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#启动脚本是在</span><br>/usr/local/nginx/sbin/nginx<br><span class="hljs-comment">#启动,</span><br>/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf<br><span class="hljs-comment">#停止</span><br>/usr/local/nginx/sbin/nginx -s stop<br><span class="hljs-comment">#重载</span><br>/usr/local/nginx/sbin/nginx -s reload<br><span class="hljs-comment">#杀掉nginx</span><br>/usr/local/nginx/sbin/nginx -s quit<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>常用工具问题及解决办法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>刷题</title>
    <link href="/2023/09/01/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/"/>
    <url>/2023/09/01/%E7%AE%97%E6%B3%95/%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="0-常用法"><a href="#0-常用法" class="headerlink" title="0.常用法"></a>0.常用法</h1><ul><li>Character的用法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//判断一个char是不是数字</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Character.isDigit();<br><span class="hljs-comment">//判断一个char是不是字母</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Character.isLetter();<br><span class="hljs-comment">//判断一个char是不是大写字母</span><br>Character.isUpperCase(ch)<br><span class="hljs-comment">//判断一个char是不是小写字母</span><br>Character.isLowerCase(ch)<br></code></pre></td></tr></table></figure><ul><li>向上取整</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> Math.ceil(num);<br></code></pre></td></tr></table></figure><ul><li>指数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Math.pow(x, y)<br></code></pre></td></tr></table></figure><ul><li>float转String，且小数点后面指定位数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">float</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">123.456f</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;%.2f&quot;</span>, f); <span class="hljs-comment">// 保留两位小数</span><br></code></pre></td></tr></table></figure><ul><li>Int转化为二进制</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> Integer.toBinaryString();<br></code></pre></td></tr></table></figure><ul><li>对数组的[i,j]部分进行排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(nums, i, j);<br></code></pre></td></tr></table></figure><ul><li>请将它对10^9 + 7取余</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br></code></pre></td></tr></table></figure><ul><li>判断两个数组中的内容是否相同</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.equals(array1, array2)<br></code></pre></td></tr></table></figure><ul><li>防止负数相加溢出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE / <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><ul><li>控制continue跳转的位置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">next:<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; strs.length; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; strs.length; j++) &#123;<br>        <span class="hljs-keyword">if</span> (j != i &amp;&amp; isSubseq(strs[i], strs[j])) &#123;<br>            <span class="hljs-keyword">continue</span> next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> strs[i].length();<br>&#125;<br></code></pre></td></tr></table></figure><p>这会导致外层循环继续下一次迭代，而不需要执行内层循环的剩余部分。</p><ul><li>遍历set</li></ul><p>增强for</p><h1 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h1><h2 id="1-1知识点："><a href="#1-1知识点：" class="headerlink" title="1.1知识点："></a>1.1知识点：</h2><ul><li>二分查找</li></ul><p>​见二分查找章节</p><ul><li>快慢指针</li><li>滑动窗口</li><li>矩阵题目（主要是模拟，都比较难）</li><li>循环数组（503）：1.再开辟一个数组，拼接到原数组；2.遍历时候按2倍数组遍历，i 取 i % nums.length</li></ul><h2 id="1-2用法："><a href="#1-2用法：" class="headerlink" title="1.2用法："></a>1.2用法：</h2><p>&#x2F;&#x2F;数组的填充</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span>[] c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[n];<br>Arrays.fill(c, <span class="hljs-string">&#x27;.&#x27;</span>);<br></code></pre></td></tr></table></figure><p>判断两个数组是否相等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> Arrays.equals(arr1, arr2);<br></code></pre></td></tr></table></figure><p>数组的自定义排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//二维数组排序</span><br><span class="hljs-comment">//如果 compare(a, b) 返回正数，则意味着元素 a 在排序中应该排在元素 b 的后面。</span><br>Arrays.sort(arr, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr1, <span class="hljs-type">int</span>[] arr2)</span> &#123;<br>                <span class="hljs-keyword">return</span> arr1[<span class="hljs-number">0</span>] - arr2[<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure><p>数组初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//数组初始化</span><br><span class="hljs-comment">//1.static</span><br><span class="hljs-type">int</span>[] numbers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span>[] numbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-comment">//2.dynamic</span><br><span class="hljs-type">int</span>[] numbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br><br><span class="hljs-comment">//二维数组初始化</span><br><span class="hljs-comment">//第一种方式：</span><br><span class="hljs-type">int</span> a[][]=&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;&#125;;<br><span class="hljs-comment">//第二种方式；</span><br><span class="hljs-type">int</span>[][] ints = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>];<br><span class="hljs-comment">//第三种方式：第二维的长度可以动态申请</span><br><span class="hljs-type">int</span>[][] arr3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>][];<span class="hljs-comment">//五行的长度</span><br></code></pre></td></tr></table></figure><p>list的用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//清空</span><br>list.clear();<br><span class="hljs-comment">//升序</span><br>Collections.sort(list);<br><span class="hljs-comment">//降序</span><br>Collections.sort(list, Collections.reverseOrder());<br><span class="hljs-comment">//删除最近添加的元素</span><br>list.removeLast();<br><span class="hljs-comment">//注意这两句的区别，回溯中选择第二个</span><br>ans.add(path);<br>ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br></code></pre></td></tr></table></figure><h2 id="1-3困难题目"><a href="#1-3困难题目" class="headerlink" title="1.3困难题目"></a>1.3困难题目</h2><p>矩阵题目全部、34.在排序数组中查找元素的第一个和最后一个位置（两次二分，查第一个和最后一个位置）、</p><h1 id="2-链表"><a href="#2-链表" class="headerlink" title="2.链表"></a>2.链表</h1><h2 id="2-1知识点："><a href="#2-1知识点：" class="headerlink" title="2.1知识点："></a>2.1知识点：</h2><p>经常需要创造出一个虚拟节点、大部分题目画图模拟即可、合并有序链表（必须快速写）、双向链表（LRU）、链表的归并排序（148）、链表的深拷贝（138）</p><p>环形链表：</p><ul><li><p>判断链表是否环：使用快慢指针。</p></li><li><p>如果有环，如何找到这个环的入口：从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是环形入口的节点。</p></li></ul><h2 id="2-2用法"><a href="#2-2用法" class="headerlink" title="2.2用法"></a>2.2用法</h2><p>双向链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//双向链表需要自定义，引用LRU一题</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DLinkedNode</span> &#123;<br>        <span class="hljs-type">int</span> key;<br>        <span class="hljs-type">int</span> value;<br>        DLinkedNode prev;<br>        DLinkedNode next;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DLinkedNode</span><span class="hljs-params">()</span> &#123;&#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DLinkedNode</span><span class="hljs-params">(<span class="hljs-type">int</span> _key, <span class="hljs-type">int</span> _value)</span> &#123;key = _key; value = _value;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3困难题"><a href="#2-3困难题" class="headerlink" title="2.3困难题"></a>2.3困难题</h2><p>148.排序链表、146.LRU</p><h1 id="3-哈希表"><a href="#3-哈希表" class="headerlink" title="3.哈希表"></a>3.哈希表</h1><h2 id="3-1知识点"><a href="#3-1知识点" class="headerlink" title="3.1知识点"></a>3.1知识点</h2><p>有时候用一个int[26]的数组存储字母可能更好。</p><h2 id="3-2用法"><a href="#3-2用法" class="headerlink" title="3.2用法"></a>3.2用法</h2><p>map和set除了遍历外的各种时间复杂度为O（1）</p><ul><li>hashmap的用法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//遍历1.</span><br>hashMap.forEach((key, value) -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;(&quot;</span> + key + <span class="hljs-string">&quot;, &quot;</span> + value + <span class="hljs-string">&quot;)&quot;</span>);<br>        &#125;);<br><span class="hljs-comment">//遍历2.</span><br><span class="hljs-keyword">for</span> (Map.Entry &lt;Integer, String&gt; entry: map.entrySet()) &#123;<br>            key = entry.getKey();<br>            value = entry.getValue();<br>            <br>&#125;<br><span class="hljs-comment">//遍历3.</span><br>Set&lt;String&gt; set = map.keySet();<br><span class="hljs-keyword">for</span>(String key : set)&#123;<br>    ......<br>&#125;<br><span class="hljs-comment">//判断key是否存在</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> map.containsKey(key);<br><span class="hljs-comment">//获取key对应的value，若不存在获取默认值</span><br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> map.getOrDefault(key, <span class="hljs-number">0</span>);<br><span class="hljs-comment">//删除某key</span><br>map.remove(key);<br><span class="hljs-comment">//判断map是否为空</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> map.isEmpty();<br></code></pre></td></tr></table></figure><ul><li><p>set基本类似</p></li><li><p>TreeMap的使用</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//返回 TreeMap 中最小和最大的键</span><br>System.out.println(map.firstKey()); <span class="hljs-comment">// Alice</span><br>System.out.println(map.lastKey()); <span class="hljs-comment">// David</span><br><br><span class="hljs-comment">// 返回 TreeMap 中小于和大于给定键的最近的键</span><br>System.out.println(map.lowerKey(<span class="hljs-string">&quot;Bob&quot;</span>)); <span class="hljs-comment">// Alice</span><br>System.out.println(map.higherKey(<span class="hljs-string">&quot;Bob&quot;</span>)); <span class="hljs-comment">// Charlie</span><br><br><span class="hljs-comment">// 返回 TreeMap 中小于等于和大于等于给定键的最近的键</span><br>System.out.println(map.floorKey(<span class="hljs-string">&quot;Bob&quot;</span>)); <span class="hljs-comment">// Bob</span><br>System.out.println(map.ceilingKey(<span class="hljs-string">&quot;Bob&quot;</span>)); <span class="hljs-comment">// Bob</span><br><br><span class="hljs-comment">// 返回一个子映射，包含给定范围内的所有键值对</span><br>System.out.println(map.subMap(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-literal">true</span>)); <span class="hljs-comment">// &#123;Alice=90, Bob=80, Charlie=70&#125;</span><br><br><span class="hljs-comment">// 返回一个子映射，包含小于或等于给定键或大于或等于给定键的所有键值对</span><br>System.out.println(map.headMap(<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-literal">true</span>)); <span class="hljs-comment">// &#123;Alice=90, Bob=80, Charlie=70&#125;</span><br>System.out.println(map.tailMap(<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-literal">true</span>)); <span class="hljs-comment">// &#123;Charlie=70, David=60&#125;</span><br><br><span class="hljs-comment">// 返回 TreeMap 中最小和最大的键值对</span><br>System.out.println(map.firstEntry()); <span class="hljs-comment">// Alice=90</span><br>System.out.println(map.lastEntry()); <span class="hljs-comment">// David=60</span><br><br><span class="hljs-comment">// 返回 TreeMap 中小于和大于给定键的最近的键值对</span><br>System.out.println(map.lowerEntry(<span class="hljs-string">&quot;Bob&quot;</span>)); <span class="hljs-comment">// Alice=90</span><br>System.out.println(map.higherEntry(<span class="hljs-string">&quot;Bob&quot;</span>)); <span class="hljs-comment">// Charlie=70</span><br><br><span class="hljs-comment">// 返回 TreeMap 中小于等于和大于等于给定键的最近的键值对</span><br>System.out.println(map.floorEntry(<span class="hljs-string">&quot;Bob&quot;</span>)); <span class="hljs-comment">// Bob=80</span><br>System.out.println(map.ceilingEntry(<span class="hljs-string">&quot;Bob&quot;</span>)); <span class="hljs-comment">// Bob=80</span><br><br><span class="hljs-comment">// 返回并删除 TreeMap 中最小和最大的键值对</span><br>System.out.println(map.pollFirstEntry()); <span class="hljs-comment">// Alice=90</span><br>System.out.println(map.pollLastEntry()); <span class="hljs-comment">// David=60</span><br></code></pre></td></tr></table></figure><p>自定义排序：类似堆</p><h1 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4.字符串"></a>4.字符串</h1><h2 id="4-1知识点"><a href="#4-1知识点" class="headerlink" title="4.1知识点"></a>4.1知识点</h2><p>前缀和(560.)</p><p><img src="/../../images/image-20240802155636132.png" alt="image-20240802155636132"></p><h2 id="4-2用法"><a href="#4-2用法" class="headerlink" title="4.2用法"></a>4.2用法</h2><p>string的常用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">1.比较string要用equals()而不是==</span><br><span class="hljs-comment">2.string str = “”和string str = null不一样</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//string转char</span><br><span class="hljs-type">char</span>[] charArr = s.toCharArray();<br><span class="hljs-comment">//char数组转string</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(charArray);<br><span class="hljs-comment">//string转int</span><br><span class="hljs-type">String</span> <span class="hljs-variable">numberStr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> Integer.valueOf(numberStr);<br><span class="hljs-comment">//int转string</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> String.valueOf(num);<br><span class="hljs-comment">//切割字符串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;This\tis\ta\tsample\tstring&quot;</span>;<br>String[] words = text.split(<span class="hljs-string">&quot;\t&quot;</span>); <span class="hljs-comment">// 使用制表符分割字符串</span><br><span class="hljs-comment">//去掉开头和结尾的空格</span><br><span class="hljs-type">String</span> <span class="hljs-variable">originalString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;   Hello, world!   &quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">trimmedString</span> <span class="hljs-operator">=</span> originalString.trim();<br><span class="hljs-comment">//取string的第i位置的字符</span><br>str.charAt();<br><span class="hljs-comment">//string的取子串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">substr1</span> <span class="hljs-operator">=</span> str.substring(<span class="hljs-number">7</span>); <span class="hljs-comment">// 从索引7开始截取到字符串末尾</span><br><span class="hljs-type">String</span> <span class="hljs-variable">substr2</span> <span class="hljs-operator">=</span> str.substring(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 从索引 0 开始截取到索引 5（不包括）  左闭右开</span><br><br><span class="hljs-comment">//contains只能包含字符串，如果希望检测是否包含某字符使用indexOf</span><br><br><span class="hljs-comment">//比较两个字符串对应的数字的大小  “330” “303”进行比较</span><br><span class="hljs-comment">//如果字符串相等，则返回值为 0。</span><br><span class="hljs-comment">//如果当前字符串小于参数字符串，则返回一个负整数。</span><br><span class="hljs-comment">//如果当前字符串大于参数字符串，则返回一个正整数。</span><br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> str1.compareTo(str2);<br></code></pre></td></tr></table></figure><p>stringbuilder的用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建</span><br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><span class="hljs-comment">//string转化为stringbuilder</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(str);<br><span class="hljs-comment">//添加</span><br>sb.append(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-comment">//往指定位置插入字符串</span><br>sb.insert(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;beautiful &quot;</span>); <span class="hljs-comment">// 在索引为 5 的位置插入字符串</span><br><span class="hljs-comment">//删除字符串</span><br>sb.delete(<span class="hljs-number">5</span>, <span class="hljs-number">14</span>); <span class="hljs-comment">// 删除索引从 5 到 13 的字符</span><br><span class="hljs-comment">//删除固定位置的字符</span><br>sb.deleteCharAt(<span class="hljs-type">int</span> index);<span class="hljs-comment">// 删除指定索引处的字符。</span><br><span class="hljs-comment">//把指定位置处的字符替换为另一个字符</span><br>sb.setCharAt(index, newChar);<br><span class="hljs-comment">//获取长度</span><br><span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> sb.length();<br><span class="hljs-comment">//获取指定位置的字符</span><br><span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> sb.charAt(<span class="hljs-number">0</span>); <span class="hljs-comment">// 获取索引为 0 的字符</span><br><span class="hljs-comment">//反转字符串</span><br>sb.reverse();<br><span class="hljs-comment">//转化为string</span><br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> sb.toString();<br></code></pre></td></tr></table></figure><p>kmp算法跳过</p><h2 id="4-3困难题目"><a href="#4-3困难题目" class="headerlink" title="4.3困难题目"></a>4.3困难题目</h2><h1 id="5-栈与队列"><a href="#5-栈与队列" class="headerlink" title="5.栈与队列"></a>5.栈与队列</h1><h2 id="5-1知识点"><a href="#5-1知识点" class="headerlink" title="5.1知识点"></a>5.1知识点</h2><p>辅助栈（155）、</p><p>分数字栈和符号栈（150、394）</p><p>单调栈（例子4，2，0，3，2，5）：求右边第一个比它大的元素——单调递减栈（从栈底到栈头）；求右边第一个比它小的元素——单调递增栈、</p><p>优先队列、</p><p>单调队列：维护某个范围内的最值使用</p><h2 id="5-2用法"><a href="#5-2用法" class="headerlink" title="5.2用法"></a>5.2用法</h2><p>栈的常用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//栈</span><br>Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><span class="hljs-comment">//常用方法</span><br>push();<br>pop();<br>isEmpty();<br>peek() <span class="hljs-comment">//检索但不删除此列表的头（第一个元素）。</span><br></code></pre></td></tr></table></figure><p>队列的常用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//队列</span><br>Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><span class="hljs-comment">//常用方法</span><br>offer();<br>poll();<br>isEmpty();<br>peek();<br><span class="hljs-comment">//双向队列的方法</span><br>offerLast();<br>offerFirst();<br><br><span class="hljs-comment">//优先队列</span><br>PriorityQueue&lt;Integer&gt; priorityQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br><span class="hljs-comment">//常用方法同队列</span><br><span class="hljs-comment">//默认是从小到大，可以通过提供一个自定义的 Comparator 来改变 PriorityQueue 的排序方式。</span><br>PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-comment">//如果 compare(a, b) 返回正数，则意味着元素 a 在排序中应该排在元素 b 的后面。</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer a, Integer b)</span> &#123;<br>                <span class="hljs-keyword">return</span> map.get(a) - map.get(b);<br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure><h2 id="5-3困难题目"><a href="#5-3困难题目" class="headerlink" title="5.3困难题目"></a>5.3困难题目</h2><p>394.字符串解码、42.接雨水、239.滑动窗口最大值（单调队列）</p><h1 id="6-二叉树"><a href="#6-二叉树" class="headerlink" title="6.二叉树"></a>6.二叉树</h1><h2 id="6-1知识点"><a href="#6-1知识点" class="headerlink" title="6.1知识点"></a>6.1知识点</h2><ul><li><p>递归三要素（1.确定参数和返回值。2.确定终止条件。3.确定单层递归的逻辑。）</p></li><li><p>各种遍历方式的非递归写法</p></li><li><p>各种遍历方式、各种遍历方式+双指针、各种遍历方式+全局变量</p></li><li><p>深度和高度：（高度和深度是相反的，求高度用后序遍历，求深度用前序遍历）</p></li><li><p>用回溯法求解二叉树问题（257.二叉树的所有路径）</p></li><li><p>DFS的应用（437.路径总和Ⅲ）</p></li><li><p>二叉搜索树（性质、搜索、插入（只往叶子节点插入）、删除（需要调整树的结构）、数组转二叉搜索树）</p></li><li><p>根据中序+前&#x2F;后序数据构造二叉树问题：需要额外四个指针，指示两个数据的起点和终点。需要一个map存储一个数组中的元素在另一个数组中的下标位置。</p></li></ul><h2 id="6-2方法"><a href="#6-2方法" class="headerlink" title="6.2方法"></a>6.2方法</h2><p>层次遍历模板</p><h2 id="6-3困难题目"><a href="#6-3困难题目" class="headerlink" title="6.3困难题目"></a>6.3困难题目</h2><p>543.二叉树的直径、450.删除二叉搜索树中的节点、669.修剪二叉搜索树、124.二叉树的最大路径和</p><h1 id="7-回溯"><a href="#7-回溯" class="headerlink" title="7.回溯"></a>7.回溯</h1><p>本质也是暴力搜索，但是在无法确定多少层for循环时使用</p><h2 id="7-1知识点"><a href="#7-1知识点" class="headerlink" title="7.1知识点"></a>7.1知识点</h2><ul><li>去重问题</li></ul><p>树层去重：同一树层上不能取相同的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在单层逻辑中去重，即for循环中</span><br><span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; used[i-<span class="hljs-number">1</span>]==<span class="hljs-literal">false</span> &amp;&amp; candidates[i-<span class="hljs-number">1</span>]==candidates[i])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><span class="hljs-comment">//used[i-1]==false确保了是树层去重，否则是树枝去重。</span><br></code></pre></td></tr></table></figure><p>树枝去重：同一树枝上不能取相同的元素</p><p><img src="/../../images/image-20240802155651192.png" alt="image-20240802155651192"></p><p>去重要借助used数组 + 对原始数组排序。</p><ul><li>组合问题</li></ul><p><img src="/../../images/image-20240802155701143.png" alt="image-20240802155701143"></p><ul><li><p>切割问题（字符串的切割）</p></li><li><p>子集问题</p></li></ul><p><img src="/../../images/image-20240802155709930.png" alt="image-20240802155709930"></p><p>组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点。</p><p>收集子集要放在终止条件上方，否则会漏掉。</p><ul><li>排列问题</li></ul><p>使用used数组</p><p><img src="/../../images/image-20240802155718485.png" alt="image-20240802155718485"></p><ul><li>棋盘问题</li></ul><p>N皇后、解数独</p><ul><li>其他</li></ul><p>dfs和回溯作比较：岛屿数量和单词搜索这两题。</p><h2 id="7-2方法"><a href="#7-2方法" class="headerlink" title="7.2方法"></a>7.2方法</h2><p>模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(参数)</span>&#123;<br><span class="hljs-keyword">if</span>(终止条件)&#123;<br>        收集结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(集合元素)&#123;<br>        处理节点；<br>        递归函数；<br>        回溯操作；<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//递归三步曲</span><br><span class="hljs-number">1.</span>递归函数参数和返回值：形参根据题目来定，返回值一般都是<span class="hljs-keyword">void</span><br><span class="hljs-number">2.</span>递归终止条件<br><span class="hljs-number">3.</span>单层搜索逻辑<br></code></pre></td></tr></table></figure><p>辅助变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//排列问题，去重问题要用used数组，组合问题，切割问题，子集问题用startindex。</span><br><br><span class="hljs-comment">//设置两个全局变量</span><br>List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-comment">//注意是收集叶子结点的数据还是收集所有结点中的数据。</span><br></code></pre></td></tr></table></figure><h2 id="7-3困难题目"><a href="#7-3困难题目" class="headerlink" title="7.3困难题目"></a>7.3困难题目</h2><p>40.组合总和Ⅱ、491.非递减子序列（不能排序的去重借助set去重）、51.N皇后（处理二维数组）</p><h1 id="8-贪心"><a href="#8-贪心" class="headerlink" title="8.贪心"></a>8.贪心</h1><h1 id="9-动态规划"><a href="#9-动态规划" class="headerlink" title="9.动态规划"></a>9.动态规划</h1><p>初始化：递推公式没有考虑到的才需要初始化。</p><h2 id="9-1知识点"><a href="#9-1知识点" class="headerlink" title="9.1知识点"></a>9.1知识点</h2><ul><li><p>简单题目</p></li><li><p>0-1背包问题</p></li></ul><p><strong>问题分类</strong></p><p>给了背包的容量，问能不能装满；</p><p>给了背包的容量，问最多能装多少价值；</p><p>给了背包的容量，有几种方法装满（递归公式不一样）；</p><p>给了背包的容量，最多能装几个物品装满；</p><p>ps：可能递归公式不一样，但遍历顺序都一样。</p><p><strong>递推公式</strong></p><p>1.二维</p><p>需要二维数组 dp[i][j] : [0,i]物品任取放进容量为j的背包中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// weight数组的大小 就是物品个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; weight.size(); i++) &#123; <span class="hljs-comment">// 遍历物品</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= bagweight; j++) &#123; <span class="hljs-comment">// 遍历背包容量</span><br>        <span class="hljs-keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        <span class="hljs-keyword">else</span> dp[i][j] = max(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//遍历顺序</span><br>两层<span class="hljs-keyword">for</span>，先物品后容量或者先容量后物品，对于二维数组实现的<span class="hljs-number">0</span>-<span class="hljs-number">1</span>背包，顺序都可以。<br>可以看画表的遍历顺序确定。<br></code></pre></td></tr></table></figure><p>2.一维数组</p><p>对二维数组的改进，直接把上一层拷贝到当前层</p><p>因为从右边开始才能保证你的dp[j-w[i]]这个是上一层的呀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; wLen; i++)&#123;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> bagWeight; j &gt;= weight[i]; j--)&#123;<br>        dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//遍历顺序</span><br>先物品后背包，不能颠倒；<br>且背包应该是倒叙遍历（倒叙保证了物品只被添加一次）。<br></code></pre></td></tr></table></figure><ul><li>完全背包</li></ul><p>同一件物品可以使用无数次；背包改为正序遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; wLen; i++)&#123;<br>           <span class="hljs-comment">//for (int j = bagWeight; j &gt;= weight[i]; j--)</span><br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> weight[i]; j &lt;= bagWeight; j++)&#123;<br>                dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);<br>            &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据不同题目，两层for循环的顺序会有所不同，先物品后背包对应组合问题，先背包后物品对应排序问题。</p><p>纯完全背包问题：两层for循环任意</p><p>组合问题：先物品后背包</p><p>排列问题：先背包后物品（可以剪枝）</p><ul><li>打家劫舍：有点像简单的动规问题。</li><li>股票问题：</li></ul><p>二维dp问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//递推公式</span><br><span class="hljs-comment">//需要二维dp数组，dp[i][0]:不持有股票的最大利润，dp[i][1]:持有股票的最大利润。</span><br>dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);<br>dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], -prices[i]);<br><br><span class="hljs-comment">//初始化</span><br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><ul><li>子序列问题</li></ul><p>子序列（不连续）、子序列（连续）、二维子序列（二维dp）、编辑距离（难）、</p><p>回文：需要二维dp数组（boolean），i，j表示 i 到 j 范围内的子串是否是回文的；且遍历顺序有讲究。</p><ul><li>152.乘积最大子数组</li></ul><p>借助两个dp[]数组共同实现。</p><h2 id="9-2方法"><a href="#9-2方法" class="headerlink" title="9.2方法"></a>9.2方法</h2><p><strong>动规五步曲：</strong></p><ol><li>确定dp数组以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><h2 id="9-3困难题"><a href="#9-3困难题" class="headerlink" title="9.3困难题"></a>9.3困难题</h2><p>343.整数拆分、96.不同的二叉搜索树、213.打家劫舍Ⅱ、编辑距离所有题目、647.回文子串、516.最长回文子序列、123.买股票的最佳时机Ⅲ（状态增加）</p><h1 id="10-图论"><a href="#10-图论" class="headerlink" title="10.图论"></a>10.图论</h1><h2 id="10-1知识点"><a href="#10-1知识点" class="headerlink" title="10.1知识点"></a>10.1知识点</h2><p>DFS、BFS、拓扑排序、</p><p>邻接表表示（3067）、</p><p>并查集：</p><ul><li>将两个元素添加到一个集合中。</li><li>判断两个元素在不在同一个集合。</li></ul><h2 id="10-2方法"><a href="#10-2方法" class="headerlink" title="10.2方法"></a>10.2方法</h2><p><strong>DFS模板</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(参数)</span> &#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本节点所连接的其他节点) &#123;<br>        处理节点;<br>        dfs(图，选择的节点); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>DFS三步曲：</strong></p><ol><li>确认递归函数，参数</li><li>确认终止条件</li><li>处理目前搜索节点出发的路径</li></ol><p><strong>BFS模板</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//类似层序遍历</span><br></code></pre></td></tr></table></figure><p><strong>邻接表</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;<span class="hljs-type">int</span>[]&gt;[] graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>[n];<br>Arrays.setAll(graph, i -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] e : edges) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> e[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> e[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> e[<span class="hljs-number">2</span>];<br>    graph[u].add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;v, w&#125;);<br>    graph[v].add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;u, w&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>74.搜索二维矩阵和240.搜索二维矩阵Ⅱ：（当每行元素为升序且每行的第一个整数大于前一行的最后一个整数时，可以使用两次二分查找找到任意一个元素；当只有行和列是升序时，无法使用两次二分）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//闭区间[low, high]写法</span><br><span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> arr.length-<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (low &lt;= high)&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (low + high)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (arr[mid] &lt; key)&#123;<br>        low = mid + <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        high = mid -<span class="hljs-number">1</span>;<br>    &#125;<br><span class="hljs-keyword">return</span> low;<br></code></pre></td></tr></table></figure><ul><li><p>最终的结果：low的左侧都是low的满足判断条件的，high的右侧都是满足high的判断条件的。</p></li><li><p>当二分查找结束后，low &#x3D; high + 1, low - 1指向的一定是 &lt; target的数， high + 1 指向的一定是 &gt; &#x3D;target的数。</p></li><li><p>针对&gt;,&lt;,&gt;&#x3D;,&lt;&#x3D;的情况</p></li></ul><p>大于：可以看作大于等于target+1的情况</p><p>小于：大于等于target的那个数左边的那个数</p><p>小于等于：大于target左边的那个数</p><p>34.当数组中有重复元素时，使用传统二分无法确定找到的是多个重复元素中的哪个。</p><h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><ul><li>求解最大公因数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : gcd(b, a % b);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>判断是否是质数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i * i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n &gt;= <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//快速计算一个数字二进制中1的个数</span><br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> Integer.bitCount(num);<br></code></pre></td></tr></table></figure><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h2 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h2><p><strong>初始化</strong>：</p><p>定义preSum[0] &#x3D; 0</p><p><img src="/../../images/image-20240802160315812.png" alt="image-20240802160315812"></p><p><strong>计算任意区间的和</strong>：</p><p>[left,right]区间的和为 ： preSum[right + 1] - preSum[left]</p><h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><p><strong>初始化二维前缀和</strong></p><p><img src="/../../images/image-20240802160322899.png" alt="image-20240802160322899"></p><p><strong>计算任意子矩阵元素和</strong></p><p><img src="/../../images/image-20240802160329080.png" alt="image-20240802160329080"></p><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>用于处理一些不相交集合的合并问题，即连通性问题。</p><p>针对无向图。</p><p>并查集我们一般用一维数组来记录，二维可以转化为一维。</p><p>并查集主要有两个功能：</p><ul><li>将两个元素添加到一个集合中。</li><li>判断两个元素在不在同一个集合。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br>    <span class="hljs-type">int</span>[] parents;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnionFind</span><span class="hljs-params">(<span class="hljs-type">int</span> totalNodes)</span> &#123;<br>        parents = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[totalNodes];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; totalNodes; i++) &#123;<br>            parents[i] = i;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">// 合并连通区域是通过find来操作的, 即看这两个节点是不是在一个连通区域内.</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">union</span><span class="hljs-params">(<span class="hljs-type">int</span> node1, <span class="hljs-type">int</span> node2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">root1</span> <span class="hljs-operator">=</span> find(node1);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">root2</span> <span class="hljs-operator">=</span> find(node2);<br>        <span class="hljs-keyword">if</span> (root1 != root2) &#123;<br>            parents[root2] = root1;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span> &#123;<br>        <span class="hljs-keyword">while</span> (parents[node] != node) &#123;<br>            <span class="hljs-comment">// 当前节点的父节点 指向父节点的父节点.</span><br>            <span class="hljs-comment">// 保证一个连通区域最终的parents只有一个.</span><br>            parents[node] = parents[parents[node]];<br>            node = parents[node];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> node1, <span class="hljs-type">int</span> node2)</span> &#123;<br>        <span class="hljs-keyword">return</span> find(node1) == find(node2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>题目</strong></p><p>130、721</p><h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><p>相当于动态的前缀和，更新查询都是O（logn）,克服了前缀和无法更新的缺点。</p><p><strong>使用场景</strong></p><p><a href="https://www.bilibili.com/video/BV1ce411u7qP/?spm_id_from=333.337.search-card.all.click&vd_source=08b017bec121a20e81681bf601db9437">五分钟丝滑动画讲解 | 树状数组_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1pE41197Qj/?spm_id_from=333.337.search-card.all.click&vd_source=08b017bec121a20e81681bf601db9437">〔manim | 算法 | 数据结构〕 完全理解并深入应用树状数组 | 支持多种动态维护区间操作_哔哩哔哩_bilibili</a></p><p><a href="https://blog.csdn.net/qq_63593632/article/details/122529279">蓝桥杯JAVA-12.树状数组模板（JAVA实现）_java 下载树形模板-CSDN博客</a></p><p><strong>题目</strong></p><p>3072、307</p><p><strong>使用讲解</strong></p><p>拆分[1,i]这个区间，按照二进制分解，13&#x3D;8+4+1，拆分后形成[13,13] [9,12] [1,8]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//树状数组模板</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryIndexedTree</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] tree;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BinaryIndexedTree</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        tree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>    &#125;<br>    <br><span class="hljs-comment">//把下标为i的元素增加x</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">while</span> (i &lt; tree.length) &#123;<br>            tree[i] += x;<br>            i += i &amp; -i;<br>        &#125;<br>    &#125;<br>    <br><span class="hljs-comment">//返回下标[1,i]元素之和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>            sum += tree[i];<br>            i -= i &amp; -i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h1><p>287.寻找重复数<a href="https://leetcode.cn/problems/find-the-duplicate-number/description/">287. 寻找重复数 - 力扣（LeetCode）</a></p><p>240.搜索二维矩阵<a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/description/">240. 搜索二维矩阵 II - 力扣（LeetCode）</a></p><p>105.从前序和中序构造二叉树<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）</a></p><p>232.用栈实现队列<a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></p><p>509.斐波那契数<a href="https://leetcode.cn/problems/fibonacci-number/description/">509. 斐波那契数 - 力扣（LeetCode）</a></p><p>153.寻找旋转数组的最小值<a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/">153. 寻找旋转排序数组中的最小值 - 力扣（LeetCode）</a></p><p>79.单词搜索<a href="https://leetcode.cn/problems/word-search/description/">79. 单词搜索 - 力扣（LeetCode）</a></p><p>191.位1的个数<a href="https://leetcode.cn/problems/number-of-1-bits/description/">191. 位1的个数 - 力扣（LeetCode）</a></p><p>50.Pow(x, n)<a href="https://leetcode.cn/problems/powx-n/description/">50. Pow(x, n) - 力扣（LeetCode）</a></p><p>237.删除链表中的节点<a href="https://leetcode.cn/problems/delete-node-in-a-linked-list/description/">237. 删除链表中的节点 - 力扣（LeetCode）</a></p><p>82.删除链表中的重复元素<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/">82. 删除排序链表中的重复元素 II - 力扣（LeetCode）</a></p><p>10.正则表达式匹配<a href="https://leetcode.cn/problems/regular-expression-matching/">10. 正则表达式匹配 - 力扣（LeetCode）</a></p><p>65.有效数字<a href="https://leetcode.cn/problems/valid-number/description/">65. 有效数字 - 力扣（LeetCode）</a></p><p>905.按奇偶排序数组<a href="https://leetcode.cn/problems/sort-array-by-parity/description/">905. 按奇偶排序数组 - 力扣（LeetCode）</a></p><p>19.删除链表的倒数第n个节点<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a></p><p>142.环形链表Ⅱ<a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">142. 环形链表 II - 力扣（LeetCode）</a></p><p>206.反转链表<a href="https://leetcode.cn/problems/reverse-linked-list/description/">206. 反转链表 - 力扣（LeetCode）</a></p><p>21.合并两个有序数组<a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/">21. 合并两个有序链表 - 力扣（LeetCode）</a></p><p>572.另一颗树的子树<a href="https://leetcode.cn/problems/subtree-of-another-tree/description/">572. 另一棵树的子树 - 力扣（LeetCode）</a></p><p>226.翻转二叉树<a href="https://leetcode.cn/problems/invert-binary-tree/description/">226. 翻转二叉树 - 力扣（LeetCode）</a></p><p>101.对称二叉树<a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树 - 力扣（LeetCode）</a></p><p>54.螺旋矩阵<a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵 - 力扣（LeetCode）</a></p><p>155.最小栈<a href="https://leetcode.cn/problems/min-stack/description/">155. 最小栈 - 力扣（LeetCode）</a></p><p>946.验证栈序列<a href="https://leetcode.cn/problems/validate-stack-sequences/description/">946. 验证栈序列 - 力扣（LeetCode）</a></p><p>102.二叉树的层序遍历</p><p>103.二叉树的锯齿形遍历<a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/">103. 二叉树的锯齿形层序遍历 - 力扣（LeetCode）</a></p><p>113.路径总和<a href="https://leetcode.cn/problems/path-sum-ii/description/">113. 路径总和 II - 力扣（LeetCode）</a></p><p>138.随机链表的复制<a href="https://leetcode.cn/problems/copy-list-with-random-pointer/description/">138. 随机链表的复制 - 力扣（LeetCode）</a></p><p>297.二叉树的序列化和反序列化<a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/description/">297. 二叉树的序列化与反序列化 - 力扣（LeetCode）</a></p><p>46.全排列<a href="https://leetcode.cn/problems/permutations/description/">46. 全排列 - 力扣（LeetCode）</a></p><p>47.全排列Ⅱ<a href="https://leetcode.cn/problems/permutations-ii/description/">47. 全排列 II - 力扣（LeetCode）</a></p><p>77.组合<a href="https://leetcode.cn/problems/combinations/description/">77. 组合 - 力扣（LeetCode）</a></p><p>169.多数元素<a href="https://leetcode.cn/problems/majority-element/description/">169. 多数元素 - 力扣（LeetCode）</a></p><p>215.数组中第k大元素<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/">215. 数组中的第K个最大元素 - 力扣（LeetCode）</a></p><p>295.数据流的中位数<a href="https://leetcode.cn/problems/find-median-from-data-stream/description/">295. 数据流的中位数 - 力扣（LeetCode）</a></p><p>53.最大子数组和<a href="https://leetcode.cn/problems/maximum-subarray/description/">53. 最大子数组和 - 力扣（LeetCode）</a></p><p>233.数字1的个数<a href="https://leetcode.cn/problems/number-of-digit-one/description/">233. 数字 1 的个数 - 力扣（LeetCode）</a></p><p>400.第n位数字<a href="https://leetcode.cn/problems/nth-digit/description/">400. 第 N 位数字 - 力扣（LeetCode）</a></p><p>179.最大数<a href="https://leetcode.cn/problems/largest-number/description/">179. 最大数 - 力扣（LeetCode）</a></p><p>91.解码方法<a href="https://leetcode.cn/problems/decode-ways/description/">91. 解码方法 - 力扣（LeetCode）</a></p><p>64.最小路径和<a href="https://leetcode.cn/problems/minimum-path-sum/description/">64. 最小路径和 - 力扣（LeetCode）</a></p><p>3.无重复字符的最长字串<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">3. 无重复字符的最长子串 - 力扣（LeetCode）</a></p><p>264.丑数Ⅱ<a href="https://leetcode.cn/problems/ugly-number-ii/description/">264. 丑数 II - 力扣（LeetCode）</a></p><p>387.字符串中的第一个唯一字符<a href="https://leetcode.cn/problems/first-unique-character-in-a-string/description/">387. 字符串中的第一个唯一字符 - 力扣（LeetCode）</a></p><p>493.翻转对<a href="https://leetcode.cn/problems/reverse-pairs/description/">493. 翻转对 - 力扣（LeetCode）</a></p><p>160.相交链表<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/">160. 相交链表 - 力扣（LeetCode）</a></p><p>34.在排序数组中查找元素的第一个和最后一个位置<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）</a></p><p>268.丢失的数字<a href="https://leetcode.cn/problems/missing-number/description/">268. 丢失的数字 - 力扣（LeetCode）</a></p><p>230.二叉搜索树中第k小的元素<a href="https://leetcode.cn/problems/missing-number/description/"><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/">230. 二叉搜索树中第K小的元素 - 力扣（LeetCode）</a></a></p><p>104.二叉树的最大深度</p><p>110.平衡二叉树<a href="https://leetcode.cn/problems/balanced-binary-tree/description/">110. 平衡二叉树 - 力扣（LeetCode）</a></p><p>260.只出现一次的数字Ⅲ<a href="https://leetcode.cn/problems/single-number-iii/description/">260. 只出现一次的数字 III - 力扣（LeetCode）</a></p><p>137.只出现一次的数字Ⅱ<a href="https://leetcode.cn/problems/single-number-ii/description/">137. 只出现一次的数字 II - 力扣（LeetCode）</a></p><p>167.两数之和Ⅱ<a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组 - 力扣（LeetCode）</a></p><p>829.连续整数求和<a href="https://leetcode.cn/problems/consecutive-numbers-sum/description/">829. 连续整数求和 - 力扣（LeetCode）</a></p><p>151.反转字符串中的单词<a href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">151. 反转字符串中的单词 - 力扣（LeetCode）</a></p><p>189.轮转数组<a href="https://leetcode.cn/problems/rotate-array/description/">189. 轮转数组 - 力扣（LeetCode）</a></p><p>239.滑动窗口最大值<a href="https://leetcode.cn/problems/sliding-window-maximum/description/">239. 滑动窗口最大值 - 力扣（LeetCode）</a></p><p>1155.掷骰子等于目标和的方法数<a href="https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/">1155. 掷骰子等于目标和的方法数</a></p><p>121.买卖股票的最佳时机<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">121. 买卖股票的最佳时机 - 力扣（LeetCode）</a></p><h1 id="技巧题目"><a href="#技巧题目" class="headerlink" title="技巧题目"></a>技巧题目</h1><h2 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h2><p>268、136</p><h1 id="非常规题目"><a href="#非常规题目" class="headerlink" title="非常规题目"></a>非常规题目</h1><h2 id="单例模式的手写"><a href="#单例模式的手写" class="headerlink" title="单例模式的手写"></a>单例模式的手写</h2><ul><li>一个私有构造函数 （确保只能单例类自己创建实例）</li><li>一个私有静态变量 （确保只有一个实例）</li><li>一个公有静态函数 （给使用者提供调用方法）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//懒汉式一开始不会实例化，什么时候用就什么时候new，才进行实例化</span><br><span class="hljs-comment">//懒汉模式--线程不安全</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(uniqueInstance == <span class="hljs-literal">null</span>)&#123;<br>            uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//懒汉式--线程安全</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getUinqueInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>            uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>    <br>&#125;<br><span class="hljs-comment">//饿汉式--线程安全</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">uniqueInstance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>    <br>&#125;<br><span class="hljs-comment">//双重检查锁--线程安全--相当于改进的懒汉式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fixedThreadPool</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建 2 个线程的线程池</span><br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">// 创建任务</span><br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;任务被执行,线程:&quot;</span> + Thread.currentThread().getName());<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// 线程池执行任务(一次添加 4 个任务)</span><br>    threadPool.submit(runnable);  <span class="hljs-comment">// 执行方式 1:submit</span><br>&#125;<br><span class="hljs-comment">//关闭线程池</span><br>threadPool.shutdown();<br></code></pre></td></tr></table></figure><h2 id="多线程的使用"><a href="#多线程的使用" class="headerlink" title="多线程的使用"></a>多线程的使用</h2><p><a href="https://blog.csdn.net/qq_35854212/article/details/105790986">八个经典的java多线程编程题目_java线程题目-CSDN博客</a></p><p>多线程轮流输出26个字母怎么实现？ </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-comment">//字母总数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CHARACTER_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">26</span>;<br><br>    <span class="hljs-comment">//当前索引</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">currentIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//并发线程总数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THREAD_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">LOCK</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; THREAD_COUNT; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">threadName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;thread_&quot;</span> + i;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintThread</span>(threadName, i)).start();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>        <span class="hljs-comment">//线程名</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String threadName;<br><br>        <span class="hljs-comment">//线程号</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> threadNumber;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">PrintThread</span><span class="hljs-params">(String threadName, <span class="hljs-type">int</span> threadNumber)</span> &#123;<br>            <span class="hljs-built_in">this</span>.threadName = threadName;<br>            <span class="hljs-built_in">this</span>.threadNumber = threadNumber;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 判断是否完成所有打印任务</span><br>            <span class="hljs-keyword">while</span> (currentIndex &lt; CHARACTER_COUNT) &#123;<br>                <span class="hljs-comment">//判断是否是当前线程的打印任务</span><br>                <span class="hljs-keyword">if</span> (currentIndex % THREAD_COUNT == threadNumber) &#123;<br>                    <span class="hljs-comment">//上锁</span><br>                    <span class="hljs-keyword">synchronized</span> (LOCK) &#123;<br>                        <span class="hljs-keyword">if</span> (currentIndex &lt; CHARACTER_COUNT) &#123;<br>                            <span class="hljs-comment">//打印字母</span><br>                            System.out.println(threadName + <span class="hljs-string">&quot;_print_:&quot;</span> + (<span class="hljs-type">char</span>) (<span class="hljs-number">97</span> + currentIndex));<br>                            currentIndex++;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不使用锁呢？</p><p><strong>死锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLockDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resource1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">//资源 1</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resource2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">//资源 2</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (resource1) &#123;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource1&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;waiting get resource2&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (resource2) &#123;<br>                    System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource2&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;线程 1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (resource2) &#123;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource2&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;waiting get resource1&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (resource1) &#123;<br>                    System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource1&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;线程 2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="ACM模式"><a href="#ACM模式" class="headerlink" title="ACM模式"></a>ACM模式</h1><p><a href="https://blog.csdn.net/dlhjw1412/article/details/123821153">面试 | Java 算法的 ACM 模式_java acm模式-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
